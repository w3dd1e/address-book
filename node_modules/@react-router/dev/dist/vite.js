/**
 * @react-router/dev v7.0.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// vite.ts
var vite_exports = {};
__export(vite_exports, {
  reactRouter: () => reactRouterVitePlugin
});
module.exports = __toCommonJS(vite_exports);

// vite/plugin.ts
var import_node_crypto = require("crypto");
var path4 = __toESM(require("path"));
var url2 = __toESM(require("url"));
var fse = __toESM(require("fs-extra"));
var babel = __toESM(require("@babel/core"));
var import_react_router2 = require("react-router");
var import_es_module_lexer = require("es-module-lexer");
var import_jsesc = __toESM(require("jsesc"));
var import_picocolors3 = __toESM(require("picocolors"));

// typegen/index.ts
var import_node_fs2 = __toESM(require("fs"));
var Path4 = __toESM(require("pathe"));
var import_picocolors2 = __toESM(require("picocolors"));

// config/config.ts
var import_node_fs = __toESM(require("fs"));
var import_node_child_process = require("child_process");
var import_package_json = __toESM(require("@npmcli/package-json"));

// vite/vite-node.ts
var import_server = require("vite-node/server");
var import_client = require("vite-node/client");
var import_source_map = require("vite-node/source-map");

// invariant.ts
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    console.error(
      "The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose"
    );
    throw new Error(message);
  }
}

// vite/import-vite-esm-sync.ts
var vite;
async function preloadViteEsm() {
  vite = await import("vite");
}
function importViteEsmSync() {
  invariant(vite, "importViteEsmSync() called before preloadViteEsm()");
  return vite;
}

// vite/vite-node.ts
async function createContext(viteConfig = {}) {
  await preloadViteEsm();
  const vite2 = importViteEsmSync();
  const devServer = await vite2.createServer(
    vite2.mergeConfig(
      {
        server: {
          preTransformRequests: false,
          hmr: false
        },
        optimizeDeps: {
          noDiscovery: true
        },
        configFile: false,
        envFile: false,
        plugins: []
      },
      viteConfig
    )
  );
  await devServer.pluginContainer.buildStart({});
  const server = new import_server.ViteNodeServer(devServer);
  (0, import_source_map.installSourcemapsSupport)({
    getSourceMap: (source) => server.getSourceMap(source)
  });
  const runner = new import_client.ViteNodeRunner({
    root: devServer.config.root,
    base: devServer.config.base,
    fetchModule(id2) {
      return server.fetchModule(id2);
    },
    resolveId(id2, importer) {
      return server.resolveId(id2, importer);
    }
  });
  return { devServer, server, runner };
}

// config/config.ts
var import_pathe = __toESM(require("pathe"));
var import_chokidar = __toESM(require("chokidar"));
var import_picocolors = __toESM(require("picocolors"));
var import_pick2 = __toESM(require("lodash/pick"));
var import_omit = __toESM(require("lodash/omit"));
var import_cloneDeep = __toESM(require("lodash/cloneDeep"));
var import_isEqual = __toESM(require("lodash/isEqual"));

// config/routes.ts
var Path = __toESM(require("pathe"));
var v = __toESM(require("valibot"));
var import_pick = __toESM(require("lodash/pick"));
function setAppDirectory(directory) {
  globalThis.__reactRouterAppDirectory = directory;
}
var routeConfigEntrySchema = v.pipe(
  v.custom((value) => {
    return !(typeof value === "object" && value !== null && "then" in value && "catch" in value);
  }, "Invalid type: Expected object but received a promise. Did you forget to await?"),
  v.object({
    id: v.optional(v.string()),
    path: v.optional(v.string()),
    index: v.optional(v.boolean()),
    caseSensitive: v.optional(v.boolean()),
    file: v.string(),
    children: v.optional(v.array(v.lazy(() => routeConfigEntrySchema)))
  })
);
var resolvedRouteConfigSchema = v.array(routeConfigEntrySchema);
function validateRouteConfig({
  routeConfigFile,
  routeConfig
}) {
  if (!routeConfig) {
    return {
      valid: false,
      message: `Route config must be the default export in "${routeConfigFile}".`
    };
  }
  if (!Array.isArray(routeConfig)) {
    return {
      valid: false,
      message: `Route config in "${routeConfigFile}" must be an array.`
    };
  }
  let { issues } = v.safeParse(resolvedRouteConfigSchema, routeConfig);
  if (issues?.length) {
    let { root, nested } = v.flatten(issues);
    return {
      valid: false,
      message: [
        `Route config in "${routeConfigFile}" is invalid.`,
        root ? `${root}` : [],
        nested ? Object.entries(nested).map(
          ([path5, message]) => `Path: routes.${path5}
${message}`
        ) : []
      ].flat().join("\n\n")
    };
  }
  return { valid: true };
}
function configRoutesToRouteManifest(appDirectory, routes, rootId = "root") {
  let routeManifest = {};
  function walk(route, parentId) {
    let id2 = route.id || createRouteId(route.file);
    let manifestItem = {
      id: id2,
      parentId,
      file: Path.isAbsolute(route.file) ? Path.relative(appDirectory, route.file) : route.file,
      path: route.path,
      index: route.index,
      caseSensitive: route.caseSensitive
    };
    if (routeManifest.hasOwnProperty(id2)) {
      throw new Error(
        `Unable to define routes with duplicate route id: "${id2}"`
      );
    }
    routeManifest[id2] = manifestItem;
    if (route.children) {
      for (let child of route.children) {
        walk(child, id2);
      }
    }
  }
  for (let route of routes) {
    walk(route, rootId);
  }
  return routeManifest;
}
function createRouteId(file) {
  return Path.normalize(stripFileExtension(file));
}
function stripFileExtension(file) {
  return file.replace(/\.[a-z0-9]+$/i, "");
}

// cli/detectPackageManager.ts
var detectPackageManager = () => {
  let { npm_config_user_agent } = process.env;
  if (!npm_config_user_agent) return void 0;
  try {
    let pkgManager = npm_config_user_agent.split("/")[0];
    if (pkgManager === "npm") return "npm";
    if (pkgManager === "pnpm") return "pnpm";
    if (pkgManager === "yarn") return "yarn";
    if (pkgManager === "bun") return "bun";
    return void 0;
  } catch {
    return void 0;
  }
};

// config/config.ts
var excludedConfigPresetKeys = ["presets"];
var mergeReactRouterConfig = (...configs) => {
  let reducer = (configA, configB) => {
    let mergeRequired = (key) => configA[key] !== void 0 && configB[key] !== void 0;
    return {
      ...configA,
      ...configB,
      ...mergeRequired("buildEnd") ? {
        buildEnd: async (...args) => {
          await Promise.all([
            configA.buildEnd?.(...args),
            configB.buildEnd?.(...args)
          ]);
        }
      } : {},
      ...mergeRequired("future") ? {
        future: {
          ...configA.future,
          ...configB.future
        }
      } : {},
      ...mergeRequired("presets") ? {
        presets: [...configA.presets ?? [], ...configB.presets ?? []]
      } : {}
    };
  };
  return configs.reduce(reducer, {});
};
var deepFreeze = (o) => {
  Object.freeze(o);
  let oIsFunction = typeof o === "function";
  let hasOwnProp = Object.prototype.hasOwnProperty;
  Object.getOwnPropertyNames(o).forEach(function(prop) {
    if (hasOwnProp.call(o, prop) && (oIsFunction ? prop !== "caller" && prop !== "callee" && prop !== "arguments" : true) && o[prop] !== null && (typeof o[prop] === "object" || typeof o[prop] === "function") && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  return o;
};
function ok(value) {
  return { ok: true, value };
}
function err(error) {
  return { ok: false, error };
}
async function resolveConfig({
  root,
  viteNodeContext,
  reactRouterConfigFile
}) {
  let reactRouterUserConfig = {};
  if (reactRouterConfigFile) {
    try {
      if (!import_node_fs.default.existsSync(reactRouterConfigFile)) {
        return err(`${reactRouterConfigFile} no longer exists`);
      }
      let configModule = await viteNodeContext.runner.executeFile(
        reactRouterConfigFile
      );
      if (configModule.default === void 0) {
        return err(`${reactRouterConfigFile} must provide a default export`);
      }
      if (typeof configModule.default !== "object") {
        return err(`${reactRouterConfigFile} must export a config`);
      }
      reactRouterUserConfig = configModule.default;
    } catch (error) {
      return err(`Error loading ${reactRouterConfigFile}: ${error}`);
    }
  }
  reactRouterUserConfig = deepFreeze((0, import_cloneDeep.default)(reactRouterUserConfig));
  let presets = (await Promise.all(
    (reactRouterUserConfig.presets ?? []).map(async (preset) => {
      if (!preset.name) {
        throw new Error(
          "React Router presets must have a `name` property defined."
        );
      }
      if (!preset.reactRouterConfig) {
        return null;
      }
      let configPreset = (0, import_omit.default)(
        await preset.reactRouterConfig({ reactRouterUserConfig }),
        excludedConfigPresetKeys
      );
      return configPreset;
    })
  )).filter(function isNotNull(value) {
    return value !== null;
  });
  let defaults = {
    basename: "/",
    buildDirectory: "build",
    serverBuildFile: "index.js",
    serverModuleFormat: "esm",
    ssr: true
  };
  let {
    appDirectory: userAppDirectory,
    basename: basename2,
    buildDirectory: userBuildDirectory,
    buildEnd,
    prerender,
    serverBuildFile,
    serverBundles,
    serverModuleFormat,
    ssr
  } = {
    ...defaults,
    // Default values should be completely overridden by user/preset config, not merged
    ...mergeReactRouterConfig(...presets, reactRouterUserConfig)
  };
  if (!ssr && serverBundles) {
    serverBundles = void 0;
  }
  let isValidPrerenderConfig = prerender == null || typeof prerender === "boolean" || Array.isArray(prerender) || typeof prerender === "function";
  if (!isValidPrerenderConfig) {
    return err(
      "The `prerender` config must be a boolean, an array of string paths, or a function returning a boolean or array of string paths"
    );
  }
  let appDirectory = import_pathe.default.resolve(root, userAppDirectory || "app");
  let buildDirectory = import_pathe.default.resolve(root, userBuildDirectory);
  let rootRouteFile = findEntry(appDirectory, "root");
  if (!rootRouteFile) {
    let rootRouteDisplayPath = import_pathe.default.relative(
      root,
      import_pathe.default.join(appDirectory, "root.tsx")
    );
    return err(
      `Could not find a root route module in the app directory as "${rootRouteDisplayPath}"`
    );
  }
  let routes = {
    root: { path: "", id: "root", file: rootRouteFile }
  };
  let routeConfigFile = findEntry(appDirectory, "routes");
  try {
    if (!routeConfigFile) {
      let routeConfigDisplayPath = import_pathe.default.relative(
        root,
        import_pathe.default.join(appDirectory, "routes.ts")
      );
      return err(`Route config file not found at "${routeConfigDisplayPath}".`);
    }
    setAppDirectory(appDirectory);
    let routeConfigExport = (await viteNodeContext.runner.executeFile(
      import_pathe.default.join(appDirectory, routeConfigFile)
    )).default;
    let routeConfig = await routeConfigExport;
    let result = validateRouteConfig({
      routeConfigFile,
      routeConfig
    });
    if (!result.valid) {
      return err(result.message);
    }
    routes = {
      ...routes,
      ...configRoutesToRouteManifest(appDirectory, routeConfig)
    };
  } catch (error) {
    return err(
      [
        import_picocolors.default.red(`Route config in "${routeConfigFile}" is invalid.`),
        "",
        error.loc?.file && error.loc?.column && error.frame ? [
          import_pathe.default.relative(appDirectory, error.loc.file) + ":" + error.loc.line + ":" + error.loc.column,
          error.frame.trim?.()
        ] : error.stack
      ].flat().join("\n")
    );
  }
  let future = {
    unstable_optimizeDeps: reactRouterUserConfig.future?.unstable_optimizeDeps ?? false
  };
  let reactRouterConfig = deepFreeze({
    appDirectory,
    basename: basename2,
    buildDirectory,
    buildEnd,
    future,
    prerender,
    routes,
    serverBuildFile,
    serverBundles,
    serverModuleFormat,
    ssr
  });
  for (let preset of reactRouterUserConfig.presets ?? []) {
    await preset.reactRouterConfigResolved?.({ reactRouterConfig });
  }
  return ok(reactRouterConfig);
}
async function createConfigLoader({
  rootDirectory: root,
  watch: watch2
}) {
  root = root ?? process.env.REACT_ROUTER_ROOT ?? process.cwd();
  let viteNodeContext = await createContext({
    root,
    mode: watch2 ? "development" : "production",
    server: !watch2 ? { watch: null } : {},
    ssr: {
      external: ssrExternals
    }
  });
  let reactRouterConfigFile = findEntry(root, "react-router.config", {
    absolute: true
  });
  let getConfig = () => resolveConfig({ root, viteNodeContext, reactRouterConfigFile });
  let appDirectory;
  let initialConfigResult = await getConfig();
  if (!initialConfigResult.ok) {
    throw new Error(initialConfigResult.error);
  }
  appDirectory = initialConfigResult.value.appDirectory;
  let lastConfig = initialConfigResult.value;
  let fsWatcher;
  let changeHandlers = [];
  return {
    getConfig,
    onChange: (handler) => {
      if (!watch2) {
        throw new Error(
          "onChange is not supported when watch mode is disabled"
        );
      }
      changeHandlers.push(handler);
      if (!fsWatcher) {
        fsWatcher = import_chokidar.default.watch(
          [
            ...reactRouterConfigFile ? [reactRouterConfigFile] : [],
            appDirectory
          ],
          { ignoreInitial: true }
        );
        fsWatcher.on("all", async (...args) => {
          let [event, rawFilepath] = args;
          let filepath = import_pathe.default.normalize(rawFilepath);
          let appFileAddedOrRemoved = appDirectory && (event === "add" || event === "unlink") && filepath.startsWith(import_pathe.default.normalize(appDirectory));
          let configCodeUpdated = Boolean(
            viteNodeContext.devServer?.moduleGraph.getModuleById(filepath)
          );
          if (configCodeUpdated || appFileAddedOrRemoved) {
            viteNodeContext.devServer?.moduleGraph.invalidateAll();
            viteNodeContext.runner?.moduleCache.clear();
          }
          if (appFileAddedOrRemoved || configCodeUpdated) {
            let result = await getConfig();
            let configChanged = result.ok && !(0, import_isEqual.default)(lastConfig, result.value);
            let routeConfigChanged = result.ok && !(0, import_isEqual.default)(lastConfig?.routes, result.value.routes);
            for (let handler2 of changeHandlers) {
              handler2({
                result,
                configCodeUpdated,
                configChanged,
                routeConfigChanged,
                path: filepath,
                event
              });
            }
            if (result.ok) {
              lastConfig = result.value;
            }
          }
        });
      }
      return () => {
        changeHandlers = changeHandlers.filter(
          (changeHandler) => changeHandler !== handler
        );
      };
    },
    close: async () => {
      changeHandlers = [];
      await viteNodeContext.devServer.close();
      await fsWatcher?.close();
    }
  };
}
async function resolveEntryFiles({
  rootDirectory,
  reactRouterConfig
}) {
  let { appDirectory } = reactRouterConfig;
  let defaultsDirectory = import_pathe.default.resolve(
    import_pathe.default.dirname(require.resolve("@react-router/dev/package.json")),
    "dist",
    "config",
    "defaults"
  );
  let userEntryClientFile = findEntry(appDirectory, "entry.client");
  let userEntryServerFile = findEntry(appDirectory, "entry.server");
  let entryServerFile;
  let entryClientFile = userEntryClientFile || "entry.client.tsx";
  let pkgJson = await import_package_json.default.load(rootDirectory);
  let deps = pkgJson.content.dependencies ?? {};
  if (userEntryServerFile) {
    entryServerFile = userEntryServerFile;
  } else {
    if (!deps["@react-router/node"]) {
      throw new Error(
        `Could not determine server runtime. Please install @react-router/node, or provide a custom entry.server.tsx/jsx file in your app directory.`
      );
    }
    if (!deps["isbot"]) {
      console.log(
        "adding `isbot@5` to your package.json, you should commit this change"
      );
      pkgJson.update({
        dependencies: {
          ...pkgJson.content.dependencies,
          isbot: "^5"
        }
      });
      await pkgJson.save();
      let packageManager = detectPackageManager() ?? "npm";
      (0, import_node_child_process.execSync)(`${packageManager} install`, {
        cwd: rootDirectory,
        stdio: "inherit"
      });
    }
    entryServerFile = `entry.server.node.tsx`;
  }
  let entryClientFilePath = userEntryClientFile ? import_pathe.default.resolve(reactRouterConfig.appDirectory, userEntryClientFile) : import_pathe.default.resolve(defaultsDirectory, entryClientFile);
  let entryServerFilePath = userEntryServerFile ? import_pathe.default.resolve(reactRouterConfig.appDirectory, userEntryServerFile) : import_pathe.default.resolve(defaultsDirectory, entryServerFile);
  return { entryClientFilePath, entryServerFilePath };
}
var ssrExternals = isInReactRouterMonorepo() ? [
  // This is only needed within this repo because these packages
  // are linked to a directory outside of node_modules so Vite
  // treats them as internal code by default.
  "react-router",
  "react-router-dom",
  "@react-router/architect",
  "@react-router/cloudflare",
  "@react-router/dev",
  "@react-router/express",
  "@react-router/node",
  "@react-router/serve"
] : void 0;
function isInReactRouterMonorepo() {
  let serverRuntimePath = import_pathe.default.dirname(
    require.resolve("@react-router/node/package.json")
  );
  let serverRuntimeParentDir = import_pathe.default.basename(
    import_pathe.default.resolve(serverRuntimePath, "..")
  );
  return serverRuntimeParentDir === "packages";
}
var entryExts = [".js", ".jsx", ".ts", ".tsx"];
function findEntry(dir, basename2, options) {
  for (let ext of entryExts) {
    let file = import_pathe.default.resolve(dir, basename2 + ext);
    if (import_node_fs.default.existsSync(file)) {
      return options?.absolute ?? false ? file : import_pathe.default.relative(dir, file);
    }
  }
  return void 0;
}

// typegen/generate.ts
var import_dedent = __toESM(require("dedent"));
var Path3 = __toESM(require("pathe"));
var Pathe2 = __toESM(require("pathe/utils"));

// typegen/paths.ts
var Path2 = __toESM(require("pathe"));
var Pathe = __toESM(require("pathe/utils"));
function getTypesDir(ctx) {
  return Path2.join(ctx.rootDirectory, ".react-router/types");
}
function getTypesPath(ctx, route) {
  return Path2.join(
    getTypesDir(ctx),
    Path2.relative(ctx.rootDirectory, ctx.config.appDirectory),
    Path2.dirname(route.file),
    "+types/" + Pathe.filename(route.file) + ".ts"
  );
}

// typegen/generate.ts
function generate(ctx, route) {
  const lineage = getRouteLineage(ctx.config.routes, route);
  const urlpath = lineage.map((route2) => route2.path).join("/");
  const typesPath = getTypesPath(ctx, route);
  const parents = lineage.slice(0, -1);
  const parentTypeImports = parents.map((parent, i) => {
    const rel = Path3.relative(
      Path3.dirname(typesPath),
      getTypesPath(ctx, parent)
    );
    const indent = i === 0 ? "" : "  ".repeat(2);
    let source = noExtension(rel);
    if (!source.startsWith("../")) source = "./" + source;
    return `${indent}import type { Info as Parent${i} } from "${source}.js"`;
  }).join("\n");
  return import_dedent.default`
    // React Router generated types for route:
    // ${route.file}

    import type * as T from "react-router/route-module"

    ${parentTypeImports}

    type Module = typeof import("../${Pathe2.filename(route.file)}.js")

    export type Info = {
      parents: [${parents.map((_, i) => `Parent${i}`).join(", ")}],
      id: "${route.id}"
      file: "${route.file}"
      path: "${route.path}"
      params: {${formatParamProperties(
    urlpath
  )}} & { [key: string]: string | undefined }
      module: Module
      loaderData: T.CreateLoaderData<Module>
      actionData: T.CreateActionData<Module>
    }

    export namespace Route {
      export type LinkDescriptors = T.LinkDescriptors
      export type LinksFunction = () => LinkDescriptors

      export type MetaArgs = T.CreateMetaArgs<Info>
      export type MetaDescriptors = T.MetaDescriptors
      export type MetaFunction = (args: MetaArgs) => MetaDescriptors

      export type HeadersArgs = T.HeadersArgs
      export type HeadersFunction = (args: HeadersArgs) => Headers | HeadersInit

      export type LoaderArgs = T.CreateServerLoaderArgs<Info>
      export type ClientLoaderArgs = T.CreateClientLoaderArgs<Info>
      export type ActionArgs = T.CreateServerActionArgs<Info>
      export type ClientActionArgs = T.CreateClientActionArgs<Info>

      export type HydrateFallbackProps = T.CreateHydrateFallbackProps<Info>
      export type ComponentProps = T.CreateComponentProps<Info>
      export type ErrorBoundaryProps = T.CreateErrorBoundaryProps<Info>
    }
  `;
}
var noExtension = (path5) => Path3.join(Path3.dirname(path5), Pathe2.filename(path5));
function getRouteLineage(routes, route) {
  const result = [];
  while (route) {
    result.push(route);
    if (!route.parentId) break;
    route = routes[route.parentId];
  }
  result.reverse();
  return result;
}
function formatParamProperties(urlpath) {
  const params = parseParams(urlpath);
  const properties = Object.entries(params).map(([name, values]) => {
    if (values.length === 1) {
      const isOptional = values[0];
      return isOptional ? `"${name}"?: string` : `"${name}": string`;
    }
    const items = values.map(
      (isOptional) => isOptional ? "string | undefined" : "string"
    );
    return `"${name}": [${items.join(", ")}]`;
  });
  return properties.join("; ");
}
function parseParams(urlpath) {
  const result = {};
  let segments = urlpath.split("/");
  segments.forEach((segment) => {
    const match = segment.match(/^:([\w-]+)(\?)?/);
    if (!match) return;
    const param = match[1];
    const isOptional = match[2] !== void 0;
    result[param] ??= [];
    result[param].push(isOptional);
    return;
  });
  const hasSplat = segments.at(-1) === "*";
  if (hasSplat) result["*"] = [false];
  return result;
}

// typegen/index.ts
async function watch(rootDirectory, { logger } = {}) {
  const ctx = await createContext2({ rootDirectory, watch: true });
  await writeAll(ctx);
  logger?.info(import_picocolors2.default.green("generated types"), { timestamp: true, clear: true });
  ctx.configLoader.onChange(async ({ result, routeConfigChanged }) => {
    if (!result.ok) {
      logger?.error(import_picocolors2.default.red(result.error), { timestamp: true, clear: true });
      return;
    }
    ctx.config = result.value;
    if (routeConfigChanged) {
      await writeAll(ctx);
      logger?.info(import_picocolors2.default.green("regenerated types"), {
        timestamp: true,
        clear: true
      });
    }
  });
  return {
    close: async () => await ctx.configLoader.close()
  };
}
async function createContext2({
  rootDirectory,
  watch: watch2
}) {
  const configLoader = await createConfigLoader({ rootDirectory, watch: watch2 });
  const configResult = await configLoader.getConfig();
  if (!configResult.ok) {
    throw new Error(configResult.error);
  }
  const config = configResult.value;
  return {
    configLoader,
    rootDirectory,
    config
  };
}
async function writeAll(ctx) {
  const typegenDir = getTypesDir(ctx);
  import_node_fs2.default.rmSync(typegenDir, { recursive: true, force: true });
  Object.values(ctx.config.routes).forEach((route) => {
    const typesPath = getTypesPath(ctx, route);
    const content = generate(ctx, route);
    import_node_fs2.default.mkdirSync(Path4.dirname(typesPath), { recursive: true });
    import_node_fs2.default.writeFileSync(typesPath, content);
  });
}

// vite/babel.ts
var import_parser = require("@babel/parser");
var t = __toESM(require("@babel/types"));
var traverse = require("@babel/traverse").default;
var generate2 = require("@babel/generator").default;

// vite/node-adapter.ts
var import_node_events = require("events");
var import_node_stream = require("stream");
var import_set_cookie_parser = require("set-cookie-parser");
var import_node = require("@react-router/node");
function fromNodeHeaders(nodeHeaders) {
  let headers = new Headers();
  for (let [key, values] of Object.entries(nodeHeaders)) {
    if (values) {
      if (Array.isArray(values)) {
        for (let value of values) {
          headers.append(key, value);
        }
      } else {
        headers.set(key, values);
      }
    }
  }
  return headers;
}
function fromNodeRequest(nodeReq, nodeRes) {
  let origin = nodeReq.headers.origin && "null" !== nodeReq.headers.origin ? nodeReq.headers.origin : `http://${nodeReq.headers.host}`;
  invariant(
    nodeReq.originalUrl,
    "Expected `nodeReq.originalUrl` to be defined"
  );
  let url3 = new URL(nodeReq.originalUrl, origin);
  let controller = new AbortController();
  let init = {
    method: nodeReq.method,
    headers: fromNodeHeaders(nodeReq.headers),
    signal: controller.signal
  };
  nodeRes.on("finish", () => controller = null);
  nodeRes.on("close", () => controller?.abort());
  if (nodeReq.method !== "GET" && nodeReq.method !== "HEAD") {
    init.body = (0, import_node.createReadableStreamFromReadable)(nodeReq);
    init.duplex = "half";
  }
  return new Request(url3.href, init);
}
async function toNodeRequest(res, nodeRes) {
  nodeRes.statusCode = res.status;
  nodeRes.statusMessage = res.statusText;
  let cookiesStrings = [];
  for (let [name, value] of res.headers) {
    if (name === "set-cookie") {
      cookiesStrings.push(...(0, import_set_cookie_parser.splitCookiesString)(value));
    } else nodeRes.setHeader(name, value);
  }
  if (cookiesStrings.length) {
    nodeRes.setHeader("set-cookie", cookiesStrings);
  }
  if (res.body) {
    let responseBody = res.body;
    let readable = import_node_stream.Readable.from(responseBody);
    readable.pipe(nodeRes);
    await (0, import_node_events.once)(readable, "end");
  } else {
    nodeRes.end();
  }
}

// vite/styles.ts
var path3 = __toESM(require("path"));
var import_react_router = require("react-router");

// vite/resolve-file-url.ts
var path2 = __toESM(require("path"));
var resolveFileUrl = ({ rootDirectory }, filePath) => {
  let vite2 = importViteEsmSync();
  let relativePath = path2.relative(rootDirectory, filePath);
  let isWithinRoot = !relativePath.startsWith("..") && !path2.isAbsolute(relativePath);
  if (!isWithinRoot) {
    return path2.posix.join("/@fs", vite2.normalizePath(filePath));
  }
  return "/" + vite2.normalizePath(relativePath);
};

// vite/styles.ts
var cssFileRegExp = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
var cssModulesRegExp = new RegExp(`\\.module${cssFileRegExp.source}`);
var isCssFile = (file) => cssFileRegExp.test(file);
var isCssModulesFile = (file) => cssModulesRegExp.test(file);
var cssUrlParamsWithoutSideEffects = ["url", "inline", "raw", "inline-css"];
var isCssUrlWithoutSideEffects = (url3) => {
  let queryString = url3.split("?")[1];
  if (!queryString) {
    return false;
  }
  let params = new URLSearchParams(queryString);
  for (let paramWithoutSideEffects of cssUrlParamsWithoutSideEffects) {
    if (
      // Parameter is blank and not explicitly set, i.e. "?url", not "?url="
      params.get(paramWithoutSideEffects) === "" && !url3.includes(`?${paramWithoutSideEffects}=`) && !url3.includes(`&${paramWithoutSideEffects}=`)
    ) {
      return true;
    }
  }
  return false;
};
var getStylesForFiles = async ({
  viteDevServer,
  rootDirectory,
  cssModulesManifest,
  files
}) => {
  let styles = {};
  let deps = /* @__PURE__ */ new Set();
  try {
    for (let file of files) {
      let normalizedPath = path3.resolve(rootDirectory, file).replace(/\\/g, "/");
      let node = await viteDevServer.moduleGraph.getModuleById(normalizedPath);
      if (!node) {
        try {
          await viteDevServer.transformRequest(
            resolveFileUrl({ rootDirectory }, normalizedPath)
          );
        } catch (err2) {
          console.error(err2);
        }
        node = await viteDevServer.moduleGraph.getModuleById(normalizedPath);
      }
      if (!node) {
        console.log(`Could not resolve module for file: ${file}`);
        continue;
      }
      await findDeps(viteDevServer, node, deps);
    }
  } catch (err2) {
    console.error(err2);
  }
  for (let dep of deps) {
    if (dep.file && isCssFile(dep.file) && !isCssUrlWithoutSideEffects(dep.url)) {
      try {
        let css = isCssModulesFile(dep.file) ? cssModulesManifest[dep.file] : (await viteDevServer.ssrLoadModule(dep.url)).default;
        if (css === void 0) {
          throw new Error();
        }
        styles[dep.url] = css;
      } catch {
        console.warn(`Could not load ${dep.file}`);
      }
    }
  }
  return Object.entries(styles).map(([fileName, css], i) => [
    `
/* ${fileName.replace(/\/\*/g, "/\\*").replace(/\*\//g, "*\\/")} */`,
    css
  ]).flat().join("\n") || void 0;
};
var findDeps = async (vite2, node, deps) => {
  let branches = [];
  async function addFromNode(node2) {
    if (!deps.has(node2)) {
      deps.add(node2);
      await findDeps(vite2, node2, deps);
    }
  }
  async function addFromUrl(url3) {
    let node2 = await vite2.moduleGraph.getModuleByUrl(url3);
    if (node2) {
      await addFromNode(node2);
    }
  }
  if (node.ssrTransformResult) {
    if (node.ssrTransformResult.deps) {
      node.ssrTransformResult.deps.forEach(
        (url3) => branches.push(addFromUrl(url3))
      );
    }
  } else {
    node.importedModules.forEach((node2) => branches.push(addFromNode(node2)));
  }
  await Promise.all(branches);
};
var groupRoutesByParentId = (manifest) => {
  let routes = {};
  Object.values(manifest).forEach((route) => {
    if (route) {
      let parentId = route.parentId || "";
      if (!routes[parentId]) {
        routes[parentId] = [];
      }
      routes[parentId].push(route);
    }
  });
  return routes;
};
var createRoutes = (manifest, parentId = "", routesByParentId = groupRoutesByParentId(manifest)) => {
  return (routesByParentId[parentId] || []).map((route) => ({
    ...route,
    children: createRoutes(manifest, route.id, routesByParentId)
  }));
};
var getStylesForUrl = async ({
  viteDevServer,
  rootDirectory,
  reactRouterConfig,
  entryClientFilePath,
  cssModulesManifest,
  build,
  url: url3
}) => {
  if (url3 === void 0 || url3.includes("?_data=")) {
    return void 0;
  }
  let routes = createRoutes(build.routes);
  let appPath = path3.relative(process.cwd(), reactRouterConfig.appDirectory);
  let documentRouteFiles = (0, import_react_router.matchRoutes)(routes, url3, build.basename)?.map(
    (match) => path3.resolve(appPath, reactRouterConfig.routes[match.route.id].file)
  ) ?? [];
  let styles = await getStylesForFiles({
    viteDevServer,
    rootDirectory,
    cssModulesManifest,
    files: [
      // Always include the client entry file when crawling the module graph for CSS
      path3.relative(rootDirectory, entryClientFilePath),
      // Then include any styles from the matched routes
      ...documentRouteFiles
    ]
  });
  return styles;
};

// vite/vmod.ts
var id = (name) => `virtual:react-router/${name}`;
var resolve3 = (id2) => `\0${id2}`;
var url = (id2) => `/@id/__x00__${id2}`;

// vite/combine-urls.ts
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// vite/remove-exports.ts
var import_babel_dead_code_elimination = require("babel-dead-code-elimination");
var removeExports = (ast, exportsToRemove) => {
  let previouslyReferencedIdentifiers = (0, import_babel_dead_code_elimination.findReferencedIdentifiers)(ast);
  let exportsFiltered = false;
  let markedForRemoval = /* @__PURE__ */ new Set();
  traverse(ast, {
    ExportDeclaration(path5) {
      if (path5.node.type === "ExportNamedDeclaration") {
        if (path5.node.specifiers.length) {
          path5.node.specifiers = path5.node.specifiers.filter((specifier) => {
            if (specifier.type === "ExportSpecifier" && specifier.exported.type === "Identifier") {
              if (exportsToRemove.includes(specifier.exported.name)) {
                exportsFiltered = true;
                return false;
              }
            }
            return true;
          });
          if (path5.node.specifiers.length === 0) {
            markedForRemoval.add(path5);
          }
        }
        if (path5.node.declaration?.type === "VariableDeclaration") {
          let declaration = path5.node.declaration;
          declaration.declarations = declaration.declarations.filter(
            (declaration2) => {
              if (declaration2.id.type === "Identifier" && exportsToRemove.includes(declaration2.id.name)) {
                exportsFiltered = true;
                return false;
              }
              if (declaration2.id.type === "ArrayPattern" || declaration2.id.type === "ObjectPattern") {
                validateDestructuredExports(declaration2.id, exportsToRemove);
              }
              return true;
            }
          );
          if (declaration.declarations.length === 0) {
            markedForRemoval.add(path5);
          }
        }
        if (path5.node.declaration?.type === "FunctionDeclaration") {
          let id2 = path5.node.declaration.id;
          if (id2 && exportsToRemove.includes(id2.name)) {
            markedForRemoval.add(path5);
          }
        }
        if (path5.node.declaration?.type === "ClassDeclaration") {
          let id2 = path5.node.declaration.id;
          if (id2 && exportsToRemove.includes(id2.name)) {
            markedForRemoval.add(path5);
          }
        }
      }
      if (path5.node.type === "ExportDefaultDeclaration" && exportsToRemove.includes("default")) {
        markedForRemoval.add(path5);
      }
    }
  });
  if (markedForRemoval.size > 0 || exportsFiltered) {
    for (let path5 of markedForRemoval) {
      path5.remove();
    }
    (0, import_babel_dead_code_elimination.deadCodeElimination)(ast, previouslyReferencedIdentifiers);
  }
};
function validateDestructuredExports(id2, exportsToRemove) {
  if (id2.type === "ArrayPattern") {
    for (let element of id2.elements) {
      if (!element) {
        continue;
      }
      if (element.type === "Identifier" && exportsToRemove.includes(element.name)) {
        throw invalidDestructureError(element.name);
      }
      if (element.type === "RestElement" && element.argument.type === "Identifier" && exportsToRemove.includes(element.argument.name)) {
        throw invalidDestructureError(element.argument.name);
      }
      if (element.type === "ArrayPattern" || element.type === "ObjectPattern") {
        validateDestructuredExports(element, exportsToRemove);
      }
    }
  }
  if (id2.type === "ObjectPattern") {
    for (let property of id2.properties) {
      if (!property) {
        continue;
      }
      if (property.type === "ObjectProperty" && property.key.type === "Identifier") {
        if (property.value.type === "Identifier" && exportsToRemove.includes(property.value.name)) {
          throw invalidDestructureError(property.value.name);
        }
        if (property.value.type === "ArrayPattern" || property.value.type === "ObjectPattern") {
          validateDestructuredExports(property.value, exportsToRemove);
        }
      }
      if (property.type === "RestElement" && property.argument.type === "Identifier" && exportsToRemove.includes(property.argument.name)) {
        throw invalidDestructureError(property.argument.name);
      }
    }
  }
}
function invalidDestructureError(name) {
  return new Error(`Cannot remove destructured export "${name}"`);
}

// vite/with-props.ts
var import_dedent2 = __toESM(require("dedent"));
var vmodId = id("with-props");
var NAMED_COMPONENT_EXPORTS = ["HydrateFallback", "ErrorBoundary"];
var plugin = {
  name: "react-router-with-props",
  enforce: "pre",
  resolveId(id2) {
    if (id2 === vmodId) return resolve3(vmodId);
  },
  async load(id2) {
    if (id2 !== resolve3(vmodId)) return;
    return import_dedent2.default`
      import { createElement as h } from "react";
      import { useActionData, useLoaderData, useMatches, useParams, useRouteError } from "react-router";

      export function withComponentProps(Component) {
        return function Wrapped() {
          const props = {
            params: useParams(),
            loaderData: useLoaderData(),
            actionData: useActionData(),
            matches: useMatches(),
          };
          return h(Component, props);
        };
      }

      export function withHydrateFallbackProps(HydrateFallback) {
        return function Wrapped() {
          const props = {
            params: useParams(),
          };
          return h(HydrateFallback, props);
        };
      }

      export function withErrorBoundaryProps(ErrorBoundary) {
        return function Wrapped() {
          const props = {
            params: useParams(),
            loaderData: useLoaderData(),
            actionData: useActionData(),
            error: useRouteError(),
          };
          return h(ErrorBoundary, props);
        };
      }
    `;
  }
};
var transform = (ast) => {
  const hocs = [];
  function getHocUid(path5, hocName) {
    const uid = path5.scope.generateUidIdentifier(hocName);
    hocs.push([hocName, uid]);
    return uid;
  }
  traverse(ast, {
    ExportDeclaration(path5) {
      if (path5.isExportDefaultDeclaration()) {
        const declaration = path5.get("declaration");
        const expr = declaration.isExpression() ? declaration.node : declaration.isFunctionDeclaration() ? toFunctionExpression(declaration.node) : void 0;
        if (expr) {
          const uid = getHocUid(path5, "withComponentProps");
          declaration.replaceWith(t.callExpression(uid, [expr]));
        }
        return;
      }
      if (path5.isExportNamedDeclaration()) {
        const decl = path5.get("declaration");
        if (decl.isVariableDeclaration()) {
          decl.get("declarations").forEach((varDeclarator) => {
            const id2 = varDeclarator.get("id");
            const init = varDeclarator.get("init");
            const expr = init.node;
            if (!expr) return;
            if (!id2.isIdentifier()) return;
            const { name } = id2.node;
            if (!NAMED_COMPONENT_EXPORTS.includes(name)) return;
            const uid = getHocUid(path5, `with${name}Props`);
            init.replaceWith(t.callExpression(uid, [expr]));
          });
          return;
        }
        if (decl.isFunctionDeclaration()) {
          const { id: id2 } = decl.node;
          if (!id2) return;
          const { name } = id2;
          if (!NAMED_COMPONENT_EXPORTS.includes(name)) return;
          const uid = getHocUid(path5, `with${name}Props`);
          decl.replaceWith(
            t.variableDeclaration("const", [
              t.variableDeclarator(
                t.identifier(name),
                t.callExpression(uid, [toFunctionExpression(decl.node)])
              )
            ])
          );
        }
      }
    }
  });
  if (hocs.length > 0) {
    ast.program.body.unshift(
      t.importDeclaration(
        hocs.map(
          ([name, identifier]) => t.importSpecifier(identifier, t.identifier(name))
        ),
        t.stringLiteral(vmodId)
      )
    );
  }
};
function toFunctionExpression(decl) {
  return t.functionExpression(
    decl.id,
    decl.params,
    decl.body,
    decl.generator,
    decl.async
  );
}

// vite/plugin.ts
var SERVER_ONLY_ROUTE_EXPORTS = ["loader", "action", "headers"];
var CLIENT_ROUTE_EXPORTS = [
  "clientAction",
  "clientLoader",
  "default",
  "ErrorBoundary",
  "handle",
  "HydrateFallback",
  "Layout",
  "links",
  "meta",
  "shouldRevalidate"
];
var ROUTE_ENTRY_QUERY_STRING = "?route-entry=1";
var isRouteEntry = (id2) => {
  return id2.endsWith(ROUTE_ENTRY_QUERY_STRING);
};
var serverBuildId = id("server-build");
var serverManifestId = id("server-manifest");
var browserManifestId = id("browser-manifest");
var hmrRuntimeId = id("hmr-runtime");
var injectHmrRuntimeId = id("inject-hmr-runtime");
var resolveRelativeRouteFilePath = (route, reactRouterConfig) => {
  let vite2 = importViteEsmSync();
  let file = route.file;
  let fullPath = path4.resolve(reactRouterConfig.appDirectory, file);
  return vite2.normalizePath(fullPath);
};
var vmods = [serverBuildId, serverManifestId, browserManifestId];
var invalidateVirtualModules = (viteDevServer) => {
  vmods.forEach((vmod) => {
    let mod = viteDevServer.moduleGraph.getModuleById(
      resolve3(vmod)
    );
    if (mod) {
      viteDevServer.moduleGraph.invalidateModule(mod);
    }
  });
};
var getHash = (source, maxLength) => {
  let hash = (0, import_node_crypto.createHash)("sha256").update(source).digest("hex");
  return typeof maxLength === "number" ? hash.slice(0, maxLength) : hash;
};
var resolveChunk = (ctx, viteManifest, absoluteFilePath) => {
  let vite2 = importViteEsmSync();
  let rootRelativeFilePath = vite2.normalizePath(
    path4.relative(ctx.rootDirectory, absoluteFilePath)
  );
  let entryChunk = viteManifest[rootRelativeFilePath + ROUTE_ENTRY_QUERY_STRING] ?? viteManifest[rootRelativeFilePath];
  if (!entryChunk) {
    let knownManifestKeys = Object.keys(viteManifest).map((key) => '"' + key + '"').join(", ");
    throw new Error(
      `No manifest entry found for "${rootRelativeFilePath}". Known manifest keys: ${knownManifestKeys}`
    );
  }
  return entryChunk;
};
var getReactRouterManifestBuildAssets = (ctx, viteManifest, entryFilePath, prependedAssetFilePaths = []) => {
  let entryChunk = resolveChunk(ctx, viteManifest, entryFilePath);
  let prependedAssetChunks = prependedAssetFilePaths.map(
    (filePath) => resolveChunk(ctx, viteManifest, filePath)
  );
  let chunks = resolveDependantChunks(viteManifest, [
    ...prependedAssetChunks,
    entryChunk
  ]);
  return {
    module: `${ctx.publicPath}${entryChunk.file}`,
    imports: dedupe(chunks.flatMap((e) => e.imports ?? [])).map((imported) => {
      return `${ctx.publicPath}${viteManifest[imported].file}`;
    }) ?? [],
    css: dedupe(chunks.flatMap((e) => e.css ?? [])).map((href) => {
      return `${ctx.publicPath}${href}`;
    }) ?? []
  };
};
function resolveDependantChunks(viteManifest, entryChunks) {
  let chunks = /* @__PURE__ */ new Set();
  function walk(chunk) {
    if (chunks.has(chunk)) {
      return;
    }
    chunks.add(chunk);
    if (chunk.imports) {
      for (let importKey of chunk.imports) {
        walk(viteManifest[importKey]);
      }
    }
  }
  for (let entryChunk of entryChunks) {
    walk(entryChunk);
  }
  return Array.from(chunks);
}
function dedupe(array2) {
  return [...new Set(array2)];
}
var writeFileSafe = async (file, contents) => {
  await fse.ensureDir(path4.dirname(file));
  await fse.writeFile(file, contents);
};
var getRouteManifestModuleExports = async (viteChildCompiler, ctx) => {
  let entries = await Promise.all(
    Object.entries(ctx.reactRouterConfig.routes).map(async ([key, route]) => {
      let sourceExports = await getRouteModuleExports(
        viteChildCompiler,
        ctx,
        route.file
      );
      return [key, sourceExports];
    })
  );
  return Object.fromEntries(entries);
};
var getRouteModuleExports = async (viteChildCompiler, ctx, routeFile, readRouteFile) => {
  if (!viteChildCompiler) {
    throw new Error("Vite child compiler not found");
  }
  let ssr = true;
  let { pluginContainer, moduleGraph } = viteChildCompiler;
  let routePath = path4.resolve(ctx.reactRouterConfig.appDirectory, routeFile);
  let url3 = resolveFileUrl(ctx, routePath);
  let resolveId = async () => {
    let result = await pluginContainer.resolveId(url3, void 0, { ssr });
    if (!result) throw new Error(`Could not resolve module ID for ${url3}`);
    return result.id;
  };
  let [id2, code] = await Promise.all([
    resolveId(),
    readRouteFile?.() ?? fse.readFile(routePath, "utf-8"),
    // pluginContainer.transform(...) fails if we don't do this first:
    moduleGraph.ensureEntryFromUrl(url3, ssr)
  ]);
  let transformed = await pluginContainer.transform(code, id2, { ssr });
  let [, exports2] = (0, import_es_module_lexer.parse)(transformed.code);
  let exportNames = exports2.map((e) => e.n);
  return exportNames;
};
var getServerBundleBuildConfig = (viteUserConfig) => {
  if (!("__reactRouterServerBundleBuildConfig" in viteUserConfig) || !viteUserConfig.__reactRouterServerBundleBuildConfig) {
    return null;
  }
  return viteUserConfig.__reactRouterServerBundleBuildConfig;
};
var getServerBuildDirectory = (ctx) => path4.join(
  ctx.reactRouterConfig.buildDirectory,
  "server",
  ...ctx.serverBundleBuildConfig ? [ctx.serverBundleBuildConfig.serverBundleId] : []
);
var getClientBuildDirectory = (reactRouterConfig) => path4.join(reactRouterConfig.buildDirectory, "client");
var defaultEntriesDir = path4.resolve(
  path4.dirname(require.resolve("@react-router/dev/package.json")),
  "dist",
  "config",
  "defaults"
);
var defaultEntries = fse.readdirSync(defaultEntriesDir).map((filename3) => path4.join(defaultEntriesDir, filename3));
invariant(defaultEntries.length > 0, "No default entries found");
var reactRouterDevLoadContext = () => ({});
var reactRouterVitePlugin = () => {
  let rootDirectory;
  let viteCommand;
  let viteUserConfig;
  let viteConfigEnv;
  let viteConfig;
  let cssModulesManifest = {};
  let viteChildCompiler = null;
  let reactRouterConfigLoader;
  let typegenWatcherPromise;
  let logger;
  let firstLoad = true;
  let ctx;
  let updatePluginContext = async () => {
    let reactRouterConfig;
    let reactRouterConfigResult = await reactRouterConfigLoader.getConfig();
    if (reactRouterConfigResult.ok) {
      reactRouterConfig = reactRouterConfigResult.value;
    } else {
      logger.error(reactRouterConfigResult.error);
      if (firstLoad) {
        process.exit(1);
      }
      return;
    }
    let { entryClientFilePath, entryServerFilePath } = await resolveEntryFiles({
      rootDirectory,
      reactRouterConfig
    });
    let publicPath = viteUserConfig.base ?? "/";
    if (reactRouterConfig.basename !== "/" && viteCommand === "serve" && !viteUserConfig.server?.middlewareMode && !reactRouterConfig.basename.startsWith(publicPath)) {
      logger.error(
        import_picocolors3.default.red(
          "When using the React Router `basename` and the Vite `base` config, the `basename` config must begin with `base` for the default Vite dev server."
        )
      );
      process.exit(1);
    }
    let viteManifestEnabled = viteUserConfig.build?.manifest === true;
    let ssrBuildCtx = viteConfigEnv.isSsrBuild && viteCommand === "build" ? {
      isSsrBuild: true,
      getReactRouterServerManifest: async () => (await generateReactRouterManifestsForBuild()).reactRouterServerManifest,
      serverBundleBuildConfig: getServerBundleBuildConfig(viteUserConfig)
    } : { isSsrBuild: false };
    firstLoad = false;
    ctx = {
      reactRouterConfig,
      rootDirectory,
      entryClientFilePath,
      entryServerFilePath,
      publicPath,
      viteManifestEnabled,
      ...ssrBuildCtx
    };
  };
  let pluginIndex = (pluginName) => {
    invariant(viteConfig);
    return viteConfig.plugins.findIndex((plugin2) => plugin2.name === pluginName);
  };
  let getServerEntry = async () => {
    invariant(viteConfig, "viteconfig required to generate the server entry");
    let routes = ctx.serverBundleBuildConfig ? (
      // For server bundle builds, the server build should only import the
      // routes for this bundle rather than importing all routes
      ctx.serverBundleBuildConfig.routes
    ) : (
      // Otherwise, all routes are imported as usual
      ctx.reactRouterConfig.routes
    );
    return `
    import * as entryServer from ${JSON.stringify(
      resolveFileUrl(ctx, ctx.entryServerFilePath)
    )};
    ${Object.keys(routes).map((key, index) => {
      let route = routes[key];
      return `import * as route${index} from ${JSON.stringify(
        resolveFileUrl(
          ctx,
          resolveRelativeRouteFilePath(route, ctx.reactRouterConfig)
        ) + ROUTE_ENTRY_QUERY_STRING
      )};`;
    }).join("\n")}
      export { default as assets } from ${JSON.stringify(serverManifestId)};
      export const assetsBuildDirectory = ${JSON.stringify(
      path4.relative(
        ctx.rootDirectory,
        getClientBuildDirectory(ctx.reactRouterConfig)
      )
    )};
      export const basename = ${JSON.stringify(ctx.reactRouterConfig.basename)};
      export const future = ${JSON.stringify(ctx.reactRouterConfig.future)};
      export const isSpaMode = ${!ctx.reactRouterConfig.ssr && ctx.reactRouterConfig.prerender == null};
      export const publicPath = ${JSON.stringify(ctx.publicPath)};
      export const entry = { module: entryServer };
      export const routes = {
        ${Object.keys(routes).map((key, index) => {
      let route = routes[key];
      return `${JSON.stringify(key)}: {
          id: ${JSON.stringify(route.id)},
          parentId: ${JSON.stringify(route.parentId)},
          path: ${JSON.stringify(route.path)},
          index: ${JSON.stringify(route.index)},
          caseSensitive: ${JSON.stringify(route.caseSensitive)},
          module: route${index}
        }`;
    }).join(",\n  ")}
      };`;
  };
  let loadViteManifest = async (directory) => {
    let manifestContents = await fse.readFile(
      path4.resolve(directory, ".vite", "manifest.json"),
      "utf-8"
    );
    return JSON.parse(manifestContents);
  };
  let hasDependency = (name) => {
    try {
      return Boolean(require.resolve(name, { paths: [ctx.rootDirectory] }));
    } catch (err2) {
      return false;
    }
  };
  let getViteManifestAssetPaths = (viteManifest) => {
    let cssUrlPaths = Object.values(viteManifest).filter((chunk) => chunk.file.endsWith(".css")).map((chunk) => chunk.file);
    let chunkAssetPaths = Object.values(viteManifest).flatMap(
      (chunk) => chunk.assets ?? []
    );
    return /* @__PURE__ */ new Set([...cssUrlPaths, ...chunkAssetPaths]);
  };
  let generateReactRouterManifestsForBuild = async () => {
    invariant(viteConfig);
    let viteManifest = await loadViteManifest(
      getClientBuildDirectory(ctx.reactRouterConfig)
    );
    let entry = getReactRouterManifestBuildAssets(
      ctx,
      viteManifest,
      ctx.entryClientFilePath
    );
    let browserRoutes = {};
    let serverRoutes = {};
    let routeManifestExports = await getRouteManifestModuleExports(
      viteChildCompiler,
      ctx
    );
    for (let [key, route] of Object.entries(ctx.reactRouterConfig.routes)) {
      let routeFilePath = path4.join(
        ctx.reactRouterConfig.appDirectory,
        route.file
      );
      let sourceExports = routeManifestExports[key];
      let isRootRoute = route.parentId === void 0;
      let routeManifestEntry = {
        id: route.id,
        parentId: route.parentId,
        path: route.path,
        index: route.index,
        caseSensitive: route.caseSensitive,
        hasAction: sourceExports.includes("action"),
        hasLoader: sourceExports.includes("loader"),
        hasClientAction: sourceExports.includes("clientAction"),
        hasClientLoader: sourceExports.includes("clientLoader"),
        hasErrorBoundary: sourceExports.includes("ErrorBoundary"),
        ...getReactRouterManifestBuildAssets(
          ctx,
          viteManifest,
          routeFilePath,
          // If this is the root route, we also need to include assets from the
          // client entry file as this is a common way for consumers to import
          // global reset styles, etc.
          isRootRoute ? [ctx.entryClientFilePath] : []
        )
      };
      browserRoutes[key] = routeManifestEntry;
      let serverBundleRoutes = ctx.serverBundleBuildConfig?.routes;
      if (!serverBundleRoutes || serverBundleRoutes[key]) {
        serverRoutes[key] = routeManifestEntry;
      }
    }
    let fingerprintedValues = { entry, routes: browserRoutes };
    let version = getHash(JSON.stringify(fingerprintedValues), 8);
    let manifestPath = path4.posix.join(
      viteConfig.build.assetsDir,
      `manifest-${version}.js`
    );
    let url3 = `${ctx.publicPath}${manifestPath}`;
    let nonFingerprintedValues = { url: url3, version };
    let reactRouterBrowserManifest = {
      ...fingerprintedValues,
      ...nonFingerprintedValues
    };
    await writeFileSafe(
      path4.join(getClientBuildDirectory(ctx.reactRouterConfig), manifestPath),
      `window.__reactRouterManifest=${JSON.stringify(
        reactRouterBrowserManifest
      )};`
    );
    let reactRouterServerManifest = {
      ...reactRouterBrowserManifest,
      routes: serverRoutes
    };
    return {
      reactRouterBrowserManifest,
      reactRouterServerManifest
    };
  };
  let getReactRouterManifestForDev = async () => {
    let routes = {};
    let routeManifestExports = await getRouteManifestModuleExports(
      viteChildCompiler,
      ctx
    );
    for (let [key, route] of Object.entries(ctx.reactRouterConfig.routes)) {
      let sourceExports = routeManifestExports[key];
      routes[key] = {
        id: route.id,
        parentId: route.parentId,
        path: route.path,
        index: route.index,
        caseSensitive: route.caseSensitive,
        module: combineURLs(
          ctx.publicPath,
          `${resolveFileUrl(
            ctx,
            resolveRelativeRouteFilePath(route, ctx.reactRouterConfig)
          )}${ROUTE_ENTRY_QUERY_STRING}`
        ),
        hasAction: sourceExports.includes("action"),
        hasLoader: sourceExports.includes("loader"),
        hasClientAction: sourceExports.includes("clientAction"),
        hasClientLoader: sourceExports.includes("clientLoader"),
        hasErrorBoundary: sourceExports.includes("ErrorBoundary"),
        imports: []
      };
    }
    return {
      version: String(Math.random()),
      url: combineURLs(ctx.publicPath, url(browserManifestId)),
      hmr: {
        runtime: combineURLs(
          ctx.publicPath,
          url(injectHmrRuntimeId)
        )
      },
      entry: {
        module: combineURLs(
          ctx.publicPath,
          resolveFileUrl(ctx, ctx.entryClientFilePath)
        ),
        imports: []
      },
      routes
    };
  };
  return [
    {
      name: "react-router",
      config: async (_viteUserConfig, _viteConfigEnv) => {
        await preloadViteEsm();
        let vite2 = importViteEsmSync();
        viteUserConfig = _viteUserConfig;
        viteConfigEnv = _viteConfigEnv;
        viteCommand = viteConfigEnv.command;
        logger = vite2.createLogger(viteUserConfig.logLevel, {
          prefix: "[react-router]"
        });
        rootDirectory = viteUserConfig.root ?? process.env.REACT_ROUTER_ROOT ?? process.cwd();
        if (viteCommand === "serve") {
          typegenWatcherPromise = watch(rootDirectory, {
            // ignore `info` logs from typegen since they are redundant when Vite plugin logs are active
            logger: vite2.createLogger("warn", { prefix: "[react-router]" })
          });
        }
        reactRouterConfigLoader = await createConfigLoader({
          rootDirectory,
          watch: viteCommand === "serve"
        });
        await updatePluginContext();
        Object.assign(
          process.env,
          vite2.loadEnv(
            viteConfigEnv.mode,
            ctx.rootDirectory,
            // We override default prefix of "VITE_" with a blank string since
            // we're targeting the server, so we want to load all environment
            // variables, not just those explicitly marked for the client
            ""
          )
        );
        let baseRollupOptions = {
          // Silence Rollup "use client" warnings
          // Adapted from https://github.com/vitejs/vite-plugin-react/pull/144
          onwarn(warning, defaultHandler) {
            if (warning.code === "MODULE_LEVEL_DIRECTIVE" && warning.message.includes("use client")) {
              return;
            }
            if (viteUserConfig.build?.rollupOptions?.onwarn) {
              viteUserConfig.build.rollupOptions.onwarn(
                warning,
                defaultHandler
              );
            } else {
              defaultHandler(warning);
            }
          }
        };
        return {
          __reactRouterPluginContext: ctx,
          appType: viteCommand === "serve" && viteConfigEnv.mode === "production" && ctx.reactRouterConfig.ssr === false ? "spa" : "custom",
          ssr: {
            external: ssrExternals,
            resolve: {
              conditions: viteCommand === "build" ? [] : ["development"],
              externalConditions: viteCommand === "build" ? [] : ["development"]
            }
          },
          optimizeDeps: {
            entries: ctx.reactRouterConfig.future.unstable_optimizeDeps ? [
              ctx.entryClientFilePath,
              ...Object.values(ctx.reactRouterConfig.routes).map(
                (route) => path4.join(ctx.reactRouterConfig.appDirectory, route.file)
              )
            ] : [],
            include: [
              // Pre-bundle React dependencies to avoid React duplicates,
              // even if React dependencies are not direct dependencies.
              // https://react.dev/warnings/invalid-hook-call-warning#duplicate-react
              "react",
              "react/jsx-runtime",
              "react/jsx-dev-runtime",
              "react-dom",
              "react-dom/client",
              // Pre-bundle router dependencies to avoid router duplicates.
              // Mismatching routers cause `Error: You must render this element inside a <Remix> element`.
              "react-router",
              "react-router/dom",
              // Check to avoid "Failed to resolve dependency: react-router-dom, present in 'optimizeDeps.include'"
              ...hasDependency("react-router-dom") ? ["react-router-dom"] : []
            ]
          },
          esbuild: {
            jsx: "automatic",
            jsxDev: viteCommand !== "build"
          },
          resolve: {
            dedupe: [
              // https://react.dev/warnings/invalid-hook-call-warning#duplicate-react
              "react",
              "react-dom",
              // see description for `optimizeDeps.include`
              "react-router",
              "react-router/dom",
              "react-router-dom"
            ],
            conditions: viteCommand === "build" ? [] : ["development"]
          },
          base: viteUserConfig.base,
          // When consumer provides an allow list for files that can be read by
          // the server, ensure that the default entry files are included.
          // If we don't do this and a default entry file is used, the server
          // will throw an error that the file is not allowed to be read.
          // https://vitejs.dev/config/server-options#server-fs-allow
          server: viteUserConfig.server?.fs?.allow ? { fs: { allow: defaultEntries } } : void 0,
          // Vite config options for building
          ...viteCommand === "build" ? {
            build: {
              cssMinify: viteUserConfig.build?.cssMinify ?? true,
              ...!viteConfigEnv.isSsrBuild ? {
                manifest: true,
                outDir: getClientBuildDirectory(ctx.reactRouterConfig),
                rollupOptions: {
                  ...baseRollupOptions,
                  preserveEntrySignatures: "exports-only",
                  input: [
                    ctx.entryClientFilePath,
                    ...Object.values(ctx.reactRouterConfig.routes).map(
                      (route) => `${path4.resolve(
                        ctx.reactRouterConfig.appDirectory,
                        route.file
                      )}${ROUTE_ENTRY_QUERY_STRING}`
                    )
                  ]
                }
              } : {
                // We move SSR-only assets to client assets. Note that the
                // SSR build can also emit code-split JS files (e.g. by
                // dynamic import) under the same assets directory
                // regardless of "ssrEmitAssets" option, so we also need to
                // keep these JS files have to be kept as-is.
                ssrEmitAssets: true,
                copyPublicDir: false,
                // Assets in the public directory are only used by the client
                manifest: true,
                // We need the manifest to detect SSR-only assets
                outDir: getServerBuildDirectory(ctx),
                rollupOptions: {
                  ...baseRollupOptions,
                  preserveEntrySignatures: "exports-only",
                  input: viteUserConfig.build?.rollupOptions?.input ?? serverBuildId,
                  output: {
                    entryFileNames: ctx.reactRouterConfig.serverBuildFile,
                    format: ctx.reactRouterConfig.serverModuleFormat
                  }
                }
              }
            }
          } : void 0,
          // Vite config options for SPA preview mode
          ...viteCommand === "serve" && ctx.reactRouterConfig.ssr === false ? {
            build: {
              manifest: true,
              outDir: getClientBuildDirectory(ctx.reactRouterConfig)
            }
          } : void 0
        };
      },
      async configResolved(resolvedViteConfig) {
        await import_es_module_lexer.init;
        viteConfig = resolvedViteConfig;
        invariant(viteConfig);
        if (!viteConfig.configFile) {
          throw new Error(
            "The React Router Vite plugin requires the use of a Vite config file"
          );
        }
        let vite2 = importViteEsmSync();
        let childCompilerConfigFile = await vite2.loadConfigFromFile(
          {
            command: viteConfig.command,
            mode: viteConfig.mode,
            isSsrBuild: ctx.isSsrBuild
          },
          viteConfig.configFile
        );
        invariant(
          childCompilerConfigFile,
          "Vite config file was unable to be resolved for React Router child compiler"
        );
        let rollupPrePlugins = [
          { pluginName: "@mdx-js/rollup", displayName: "@mdx-js/rollup" }
        ];
        for (let prePlugin of rollupPrePlugins) {
          let prePluginIndex = pluginIndex(prePlugin.pluginName);
          if (prePluginIndex >= 0 && prePluginIndex > pluginIndex("react-router")) {
            throw new Error(
              `The "${prePlugin.displayName}" plugin should be placed before the React Router plugin in your Vite config file`
            );
          }
        }
        viteChildCompiler = await vite2.createServer({
          ...viteUserConfig,
          mode: viteConfig.mode,
          server: {
            watch: viteConfig.command === "build" ? null : void 0,
            preTransformRequests: false,
            hmr: false
          },
          configFile: false,
          envFile: false,
          plugins: [
            ...(childCompilerConfigFile.config.plugins ?? []).flat().filter(
              (plugin2) => typeof plugin2 === "object" && plugin2 !== null && "name" in plugin2 && plugin2.name !== "react-router" && plugin2.name !== "react-router-route-exports" && plugin2.name !== "react-router-hmr-updates"
            )
          ]
        });
        await viteChildCompiler.pluginContainer.buildStart({});
      },
      async transform(code, id2) {
        if (isCssModulesFile(id2)) {
          cssModulesManifest[id2] = code;
        }
      },
      buildStart() {
        invariant(viteConfig);
        if (viteCommand === "build" && viteConfig.mode === "production" && !viteConfig.build.ssr && viteConfig.build.sourcemap) {
          viteConfig.logger.warn(
            import_picocolors3.default.yellow(
              "\n" + import_picocolors3.default.bold("  \u26A0\uFE0F  Source maps are enabled in production\n") + [
                "This makes your server code publicly",
                "visible in the browser. This is highly",
                "discouraged! If you insist, ensure that",
                "you are using environment variables for",
                "secrets and not hard-coding them in",
                "your source code."
              ].map((line) => "     " + line).join("\n") + "\n"
            )
          );
        }
      },
      async configureServer(viteDevServer) {
        (0, import_react_router2.unstable_setDevServerHooks)({
          // Give the request handler access to the critical CSS in dev to avoid a
          // flash of unstyled content since Vite injects CSS file contents via JS
          getCriticalCss: async (build, url3) => {
            return getStylesForUrl({
              rootDirectory: ctx.rootDirectory,
              entryClientFilePath: ctx.entryClientFilePath,
              reactRouterConfig: ctx.reactRouterConfig,
              viteDevServer,
              cssModulesManifest,
              build,
              url: url3
            });
          },
          // If an error is caught within the request handler, let Vite fix the
          // stack trace so it maps back to the actual source code
          processRequestError: (error) => {
            if (error instanceof Error) {
              viteDevServer.ssrFixStacktrace(error);
            }
          }
        });
        reactRouterConfigLoader.onChange(
          async ({
            result,
            configCodeUpdated,
            configChanged,
            routeConfigChanged
          }) => {
            if (!result.ok) {
              invalidateVirtualModules(viteDevServer);
              logger.error(result.error, {
                clear: true,
                timestamp: true
              });
              return;
            }
            if (routeConfigChanged) {
              logger.info(import_picocolors3.default.green("Route config changed."), {
                clear: true,
                timestamp: true
              });
            } else if (configCodeUpdated) {
              logger.info(import_picocolors3.default.green("Config updated."), {
                clear: true,
                timestamp: true
              });
            }
            await updatePluginContext();
            if (configChanged) {
              invalidateVirtualModules(viteDevServer);
            }
          }
        );
        return () => {
          if (!viteDevServer.config.server.middlewareMode) {
            viteDevServer.middlewares.use(async (req, res, next) => {
              try {
                let build = await viteDevServer.ssrLoadModule(
                  serverBuildId
                );
                let handler = (0, import_react_router2.createRequestHandler)(build, "development");
                let nodeHandler = async (nodeReq, nodeRes) => {
                  let req2 = fromNodeRequest(nodeReq, nodeRes);
                  let res2 = await handler(
                    req2,
                    await reactRouterDevLoadContext(req2)
                  );
                  await toNodeRequest(res2, nodeRes);
                };
                await nodeHandler(req, res);
              } catch (error) {
                next(error);
              }
            });
          }
        };
      },
      writeBundle: {
        // After the SSR build is finished, we inspect the Vite manifest for
        // the SSR build and move server-only assets to client assets directory
        async handler() {
          if (!ctx.isSsrBuild) {
            return;
          }
          invariant(viteConfig);
          let clientBuildDirectory = getClientBuildDirectory(
            ctx.reactRouterConfig
          );
          let serverBuildDirectory = getServerBuildDirectory(ctx);
          let ssrViteManifest = await loadViteManifest(serverBuildDirectory);
          let ssrAssetPaths = getViteManifestAssetPaths(ssrViteManifest);
          let movedAssetPaths = [];
          for (let ssrAssetPath of ssrAssetPaths) {
            let src = path4.join(serverBuildDirectory, ssrAssetPath);
            let dest = path4.join(clientBuildDirectory, ssrAssetPath);
            if (!fse.existsSync(dest)) {
              await fse.move(src, dest);
              movedAssetPaths.push(dest);
            } else {
              await fse.remove(src);
            }
          }
          let ssrCssPaths = Object.values(ssrViteManifest).flatMap(
            (chunk) => chunk.css ?? []
          );
          await Promise.all(
            ssrCssPaths.map(
              (cssPath) => fse.remove(path4.join(serverBuildDirectory, cssPath))
            )
          );
          if (movedAssetPaths.length) {
            viteConfig.logger.info(
              [
                "",
                `${import_picocolors3.default.green("\u2713")} ${movedAssetPaths.length} asset${movedAssetPaths.length > 1 ? "s" : ""} moved from React Router server build to client assets.`,
                ...movedAssetPaths.map(
                  (movedAssetPath) => import_picocolors3.default.dim(path4.relative(ctx.rootDirectory, movedAssetPath))
                ),
                ""
              ].join("\n")
            );
          }
          if (ctx.reactRouterConfig.prerender != null && ctx.reactRouterConfig.prerender !== false) {
            await handlePrerender(
              viteConfig,
              ctx.reactRouterConfig,
              serverBuildDirectory,
              clientBuildDirectory
            );
          }
          if (!ctx.reactRouterConfig.ssr) {
            await handleSpaMode(
              viteConfig,
              ctx.reactRouterConfig,
              serverBuildDirectory,
              clientBuildDirectory
            );
          }
          if (!ctx.reactRouterConfig.ssr) {
            viteConfig.logger.info(
              [
                "Removing the server build in",
                import_picocolors3.default.green(serverBuildDirectory),
                "due to ssr:false"
              ].join(" ")
            );
            fse.removeSync(serverBuildDirectory);
          }
        }
      },
      async buildEnd() {
        await viteChildCompiler?.close();
        await reactRouterConfigLoader.close();
        let typegenWatcher = await typegenWatcherPromise;
        await typegenWatcher?.close();
      }
    },
    {
      name: "react-router-route-entry",
      enforce: "pre",
      async transform(_code, id2, options) {
        if (!isRouteEntry(id2)) return;
        let routeModuleId = id2.replace(ROUTE_ENTRY_QUERY_STRING, "");
        let routeFileName = path4.basename(routeModuleId);
        let sourceExports = await getRouteModuleExports(
          viteChildCompiler,
          ctx,
          routeModuleId
        );
        let reexports = sourceExports.filter(
          (exportName) => options?.ssr && SERVER_ONLY_ROUTE_EXPORTS.includes(exportName) || CLIENT_ROUTE_EXPORTS.includes(exportName)
        ).join(", ");
        return `export { ${reexports} } from "./${routeFileName}";`;
      }
    },
    {
      name: "react-router-virtual-modules",
      enforce: "pre",
      resolveId(id2) {
        if (vmods.includes(id2)) return resolve3(id2);
      },
      async load(id2) {
        switch (id2) {
          case resolve3(serverBuildId): {
            return await getServerEntry();
          }
          case resolve3(serverManifestId): {
            let reactRouterManifest = ctx.isSsrBuild ? await ctx.getReactRouterServerManifest() : await getReactRouterManifestForDev();
            return `export default ${(0, import_jsesc.default)(reactRouterManifest, {
              es6: true
            })};`;
          }
          case resolve3(browserManifestId): {
            if (viteCommand === "build") {
              throw new Error("This module only exists in development");
            }
            let reactRouterManifest = await getReactRouterManifestForDev();
            let reactRouterManifestString = (0, import_jsesc.default)(reactRouterManifest, {
              es6: true
            });
            return `window.__reactRouterManifest=${reactRouterManifestString};`;
          }
        }
      }
    },
    {
      name: "react-router-dot-server",
      enforce: "pre",
      async resolveId(id2, importer, options) {
        let isOptimizeDeps = viteCommand === "serve" && options?.scan === true;
        if (isOptimizeDeps || options?.ssr) return;
        let isResolving = options?.custom?.["react-router-dot-server"] ?? false;
        if (isResolving) return;
        options.custom = { ...options.custom, "react-router-dot-server": true };
        let resolved = await this.resolve(id2, importer, options);
        if (!resolved) return;
        let serverFileRE = /\.server(\.[cm]?[jt]sx?)?$/;
        let serverDirRE = /\/\.server\//;
        let isDotServer = serverFileRE.test(resolved.id) || serverDirRE.test(resolved.id);
        if (!isDotServer) return;
        if (!importer) return;
        if (viteCommand !== "build" && importer.endsWith(".html")) {
          return;
        }
        let vite2 = importViteEsmSync();
        let importerShort = vite2.normalizePath(
          path4.relative(ctx.rootDirectory, importer)
        );
        let isRoute = getRoute(ctx.reactRouterConfig, importer);
        if (isRoute) {
          let serverOnlyExports = SERVER_ONLY_ROUTE_EXPORTS.map(
            (xport) => `\`${xport}\``
          ).join(", ");
          throw Error(
            [
              import_picocolors3.default.red(`Server-only module referenced by client`),
              "",
              `    '${id2}' imported by route '${importerShort}'`,
              "",
              `  React Router automatically removes server-code from these exports:`,
              `    ${serverOnlyExports}`,
              "",
              `  But other route exports in '${importerShort}' depend on '${id2}'.`,
              "",
              "  See https://remix.run/docs/en/main/guides/vite#splitting-up-client-and-server-code",
              ""
            ].join("\n")
          );
        }
        throw Error(
          [
            import_picocolors3.default.red(`Server-only module referenced by client`),
            "",
            `    '${id2}' imported by '${importerShort}'`,
            "",
            "  See https://remix.run/docs/en/main/guides/vite#splitting-up-client-and-server-code",
            ""
          ].join("\n")
        );
      }
    },
    {
      name: "react-router-dot-client",
      async transform(code, id2, options) {
        if (!options?.ssr) return;
        let clientFileRE = /\.client(\.[cm]?[jt]sx?)?$/;
        let clientDirRE = /\/\.client\//;
        if (clientFileRE.test(id2) || clientDirRE.test(id2)) {
          let exports2 = (0, import_es_module_lexer.parse)(code)[1];
          return {
            code: exports2.map(
              ({ n: name }) => name === "default" ? "export default undefined;" : `export const ${name} = undefined;`
            ).join("\n"),
            map: null
          };
        }
      }
    },
    plugin,
    {
      name: "react-router-route-exports",
      async transform(code, id2, options) {
        let route = getRoute(ctx.reactRouterConfig, id2);
        if (!route) return;
        if (!options?.ssr && !ctx.reactRouterConfig.ssr) {
          let serverOnlyExports = (0, import_es_module_lexer.parse)(code)[1].map((exp) => exp.n).filter((exp) => SERVER_ONLY_ROUTE_EXPORTS.includes(exp));
          if (serverOnlyExports.length > 0) {
            let str = serverOnlyExports.map((e) => `\`${e}\``).join(", ");
            let message = `SPA Mode: ${serverOnlyExports.length} invalid route export(s) in \`${route.file}\`: ${str}. See https://remix.run/guides/spa-mode for more information.`;
            throw Error(message);
          }
          if (route.id !== "root") {
            let hasHydrateFallback = (0, import_es_module_lexer.parse)(code)[1].map((exp) => exp.n).some((exp) => exp === "HydrateFallback");
            if (hasHydrateFallback) {
              let message = `SPA Mode: Invalid \`HydrateFallback\` export found in \`${route.file}\`. \`HydrateFallback\` is only permitted on the root route in SPA Mode. See https://remix.run/guides/spa-mode for more information.`;
              throw Error(message);
            }
          }
        }
        let [filepath] = id2.split("?");
        let ast = (0, import_parser.parse)(code, { sourceType: "module" });
        if (!options?.ssr) {
          removeExports(ast, SERVER_ONLY_ROUTE_EXPORTS);
        }
        transform(ast);
        return generate2(ast, {
          sourceMaps: true,
          filename: id2,
          sourceFileName: filepath
        });
      }
    },
    {
      name: "react-router-inject-hmr-runtime",
      enforce: "pre",
      resolveId(id2) {
        if (id2 === injectHmrRuntimeId)
          return resolve3(injectHmrRuntimeId);
      },
      async load(id2) {
        if (id2 !== resolve3(injectHmrRuntimeId)) return;
        return [
          `import RefreshRuntime from "${hmrRuntimeId}"`,
          "RefreshRuntime.injectIntoGlobalHook(window)",
          "window.$RefreshReg$ = () => {}",
          "window.$RefreshSig$ = () => (type) => type",
          "window.__vite_plugin_react_preamble_installed__ = true"
        ].join("\n");
      }
    },
    {
      name: "react-router-hmr-runtime",
      enforce: "pre",
      resolveId(id2) {
        if (id2 === hmrRuntimeId) return resolve3(hmrRuntimeId);
      },
      async load(id2) {
        if (id2 !== resolve3(hmrRuntimeId)) return;
        let reactRefreshDir = path4.dirname(
          require.resolve("react-refresh/package.json")
        );
        let reactRefreshRuntimePath = path4.join(
          reactRefreshDir,
          "cjs/react-refresh-runtime.development.js"
        );
        return [
          "const exports = {}",
          await fse.readFile(reactRefreshRuntimePath, "utf8"),
          await fse.readFile(
            require.resolve("./static/refresh-utils.cjs"),
            "utf8"
          ),
          "export default exports"
        ].join("\n");
      }
    },
    {
      name: "react-router-react-refresh-babel",
      async transform(code, id2, options) {
        if (viteCommand !== "serve") return;
        if (id2.includes("/node_modules/")) return;
        let [filepath] = id2.split("?");
        let extensionsRE = /\.(jsx?|tsx?|mdx?)$/;
        if (!extensionsRE.test(filepath)) return;
        let devRuntime = "react/jsx-dev-runtime";
        let ssr = options?.ssr === true;
        let isJSX = filepath.endsWith("x");
        let useFastRefresh = !ssr && (isJSX || code.includes(devRuntime));
        if (!useFastRefresh) return;
        if (isRouteEntry(id2)) {
          return { code: addRefreshWrapper(ctx.reactRouterConfig, code, id2) };
        }
        let result = await babel.transformAsync(code, {
          babelrc: false,
          configFile: false,
          filename: id2,
          sourceFileName: filepath,
          parserOpts: {
            sourceType: "module",
            allowAwaitOutsideFunction: true
          },
          plugins: [[require("react-refresh/babel"), { skipEnvCheck: true }]],
          sourceMaps: true
        });
        if (result === null) return;
        code = result.code;
        let refreshContentRE = /\$Refresh(?:Reg|Sig)\$\(/;
        if (refreshContentRE.test(code)) {
          code = addRefreshWrapper(ctx.reactRouterConfig, code, id2);
        }
        return { code, map: result.map };
      }
    },
    {
      name: "react-router-hmr-updates",
      async handleHotUpdate({ server, file, modules, read }) {
        let route = getRoute(ctx.reactRouterConfig, file);
        let hmrEventData = { route: null };
        if (route) {
          let serverManifest = (await server.ssrLoadModule(serverManifestId)).default;
          let oldRouteMetadata = serverManifest.routes[route.id];
          let newRouteMetadata = await getRouteMetadata(
            ctx,
            viteChildCompiler,
            route,
            read
          );
          hmrEventData.route = newRouteMetadata;
          if (!oldRouteMetadata || [
            "hasLoader",
            "hasClientLoader",
            "hasAction",
            "hasClientAction",
            "hasErrorBoundary"
          ].some((key) => oldRouteMetadata[key] !== newRouteMetadata[key])) {
            invalidateVirtualModules(server);
          }
        }
        server.hot.send({
          type: "custom",
          event: "react-router:hmr",
          data: hmrEventData
        });
        return modules;
      }
    }
  ];
};
function addRefreshWrapper(reactRouterConfig, code, id2) {
  let route = getRoute(reactRouterConfig, id2);
  let acceptExports = route || isRouteEntry(id2) ? [
    "clientAction",
    "clientLoader",
    "handle",
    "meta",
    "links",
    "shouldRevalidate"
  ] : [];
  return "\n\n" + withCommentBoundaries(
    "REACT REFRESH HEADER",
    REACT_REFRESH_HEADER.replaceAll("__SOURCE__", JSON.stringify(id2))
  ) + "\n\n" + withCommentBoundaries("REACT REFRESH BODY", code) + "\n\n" + withCommentBoundaries(
    "REACT REFRESH FOOTER",
    REACT_REFRESH_FOOTER.replaceAll("__SOURCE__", JSON.stringify(id2)).replaceAll("__ACCEPT_EXPORTS__", JSON.stringify(acceptExports)).replaceAll("__ROUTE_ID__", JSON.stringify(route?.id))
  ) + "\n";
}
function withCommentBoundaries(label, text) {
  let begin = `// [BEGIN] ${label} `;
  begin += "-".repeat(80 - begin.length);
  let end = `// [END] ${label} `;
  end += "-".repeat(80 - end.length);
  return `${begin}
${text}
${end}`;
}
var REACT_REFRESH_HEADER = `
import RefreshRuntime from "${hmrRuntimeId}";

const inWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
let prevRefreshReg;
let prevRefreshSig;

if (import.meta.hot && !inWebWorker) {
  if (!window.__vite_plugin_react_preamble_installed__) {
    throw new Error(
      "React Router Vite plugin can't detect preamble. Something is wrong."
    );
  }

  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id) => {
    RefreshRuntime.register(type, __SOURCE__ + " " + id)
  };
  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;
}`.trim();
var REACT_REFRESH_FOOTER = `
if (import.meta.hot && !inWebWorker) {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {
    RefreshRuntime.registerExportsForReactRefresh(__SOURCE__, currentExports);
    import.meta.hot.accept((nextExports) => {
      if (!nextExports) return;
      __ROUTE_ID__ && window.__reactRouterRouteModuleUpdates.set(__ROUTE_ID__, nextExports);
      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(currentExports, nextExports, __ACCEPT_EXPORTS__);
      if (invalidateMessage) import.meta.hot.invalidate(invalidateMessage);
    });
  });
}`.trim();
function getRoute(pluginConfig, file) {
  let vite2 = importViteEsmSync();
  let routePath = vite2.normalizePath(
    path4.relative(pluginConfig.appDirectory, file)
  );
  let route = Object.values(pluginConfig.routes).find(
    (r) => vite2.normalizePath(r.file) === routePath
  );
  return route;
}
async function getRouteMetadata(ctx, viteChildCompiler, route, readRouteFile) {
  let sourceExports = await getRouteModuleExports(
    viteChildCompiler,
    ctx,
    route.file,
    readRouteFile
  );
  let info = {
    id: route.id,
    parentId: route.parentId,
    path: route.path,
    index: route.index,
    caseSensitive: route.caseSensitive,
    url: combineURLs(
      ctx.publicPath,
      "/" + path4.relative(
        ctx.rootDirectory,
        resolveRelativeRouteFilePath(route, ctx.reactRouterConfig)
      )
    ),
    module: combineURLs(
      ctx.publicPath,
      `${resolveFileUrl(
        ctx,
        resolveRelativeRouteFilePath(route, ctx.reactRouterConfig)
      )}?import`
    ),
    // Ensure the Vite dev server responds with a JS module
    hasAction: sourceExports.includes("action"),
    hasClientAction: sourceExports.includes("clientAction"),
    hasLoader: sourceExports.includes("loader"),
    hasClientLoader: sourceExports.includes("clientLoader"),
    hasErrorBoundary: sourceExports.includes("ErrorBoundary"),
    imports: []
  };
  return info;
}
async function getPrerenderBuildAndHandler(viteConfig, reactRouterConfig, serverBuildDirectory) {
  let serverBuildPath = path4.join(
    serverBuildDirectory,
    reactRouterConfig.serverBuildFile
  );
  let build = await import(url2.pathToFileURL(serverBuildPath).toString());
  let { createRequestHandler: createHandler } = await import("react-router");
  return {
    build,
    handler: createHandler(build, viteConfig.mode)
  };
}
async function handleSpaMode(viteConfig, reactRouterConfig, serverBuildDirectory, clientBuildDirectory) {
  let { handler } = await getPrerenderBuildAndHandler(
    viteConfig,
    reactRouterConfig,
    serverBuildDirectory
  );
  let request = new Request(`http://localhost${reactRouterConfig.basename}`);
  let response = await handler(request);
  let html = await response.text();
  validatePrerenderedResponse(response, html, "SPA Mode", "/");
  validatePrerenderedHtml(html, "SPA Mode");
  await fse.writeFile(path4.join(clientBuildDirectory, "index.html"), html);
  viteConfig.logger.info(
    "SPA Mode: index.html has been written to your " + import_picocolors3.default.bold(path4.relative(process.cwd(), clientBuildDirectory)) + " directory"
  );
}
async function handlePrerender(viteConfig, reactRouterConfig, serverBuildDirectory, clientBuildDirectory) {
  let { build, handler } = await getPrerenderBuildAndHandler(
    viteConfig,
    reactRouterConfig,
    serverBuildDirectory
  );
  let routes = createPrerenderRoutes(build.routes);
  let routesToPrerender;
  if (typeof reactRouterConfig.prerender === "boolean") {
    invariant(reactRouterConfig.prerender, "Expected prerender:true");
    routesToPrerender = determineStaticPrerenderRoutes(
      routes,
      viteConfig,
      true
    );
  } else if (typeof reactRouterConfig.prerender === "function") {
    routesToPrerender = await reactRouterConfig.prerender({
      getStaticPaths: () => determineStaticPrerenderRoutes(routes, viteConfig, false)
    });
  } else {
    routesToPrerender = reactRouterConfig.prerender || ["/"];
  }
  let headers = {
    // Header that can be used in the loader to know if you're running at
    // build time or runtime
    "X-React-Router-Prerender": "yes"
  };
  for (let path5 of routesToPrerender) {
    let matches = (0, import_react_router2.matchRoutes)(routes, path5);
    let hasLoaders = matches?.some((m) => m.route.loader);
    let data;
    if (hasLoaders) {
      data = await prerenderData(
        handler,
        path5,
        clientBuildDirectory,
        reactRouterConfig,
        viteConfig,
        { headers }
      );
    }
    let leafRoute = matches ? matches[matches.length - 1].route : null;
    let manifestRoute = leafRoute ? build.routes[leafRoute.id]?.module : null;
    let isResourceRoute = manifestRoute && !manifestRoute.default && !manifestRoute.ErrorBoundary && manifestRoute.loader;
    if (isResourceRoute) {
      await prerenderResourceRoute(
        handler,
        path5,
        clientBuildDirectory,
        reactRouterConfig,
        viteConfig,
        { headers }
      );
    } else {
      await prerenderRoute(
        handler,
        path5,
        clientBuildDirectory,
        reactRouterConfig,
        viteConfig,
        data ? {
          headers: {
            ...headers,
            "X-React-Router-Prerender-Data": encodeURI(data)
          }
        } : { headers }
      );
    }
  }
  await prerenderManifest(
    build,
    clientBuildDirectory,
    reactRouterConfig,
    viteConfig
  );
}
function determineStaticPrerenderRoutes(routes, viteConfig, isBooleanUsage = false) {
  let paths = ["/"];
  let paramRoutes = [];
  function recurse(subtree, prefix = "") {
    for (let route of subtree) {
      let newPath = [prefix, route.path].join("/").replace(/\/\/+/g, "/");
      if (route.path) {
        let segments = route.path.split("/");
        if (segments.some((s) => s.startsWith(":") || s === "*")) {
          paramRoutes.push(route.path);
        } else {
          paths.push(newPath);
        }
      }
      if (route.children) {
        recurse(route.children, newPath);
      }
    }
  }
  recurse(routes);
  if (isBooleanUsage && paramRoutes.length > 0) {
    viteConfig.logger.warn(
      [
        "\u26A0\uFE0F Paths with dynamic/splat params cannot be prerendered when using `prerender: true`.",
        "You may want to use the `prerender()` API to prerender the following paths:",
        ...paramRoutes.map((p) => "  - " + p)
      ].join("\n")
    );
  }
  return paths.map((p) => p.replace(/\/\/+/g, "/").replace(/(.+)\/$/, "$1"));
}
async function prerenderData(handler, prerenderPath, clientBuildDirectory, reactRouterConfig, viteConfig, requestInit) {
  let normalizedPath = `${reactRouterConfig.basename}${prerenderPath === "/" ? "/_root.data" : `${prerenderPath.replace(/\/$/, "")}.data`}`.replace(/\/\/+/g, "/");
  let request = new Request(`http://localhost${normalizedPath}`, requestInit);
  let response = await handler(request);
  let data = await response.text();
  validatePrerenderedResponse(response, data, "Prerender", normalizedPath);
  let outdir = path4.relative(process.cwd(), clientBuildDirectory);
  let outfile = path4.join(outdir, ...normalizedPath.split("/"));
  await fse.ensureDir(path4.dirname(outfile));
  await fse.outputFile(outfile, data);
  viteConfig.logger.info(`Prerender: Generated ${import_picocolors3.default.bold(outfile)}`);
  return data;
}
async function prerenderRoute(handler, prerenderPath, clientBuildDirectory, reactRouterConfig, viteConfig, requestInit) {
  let normalizedPath = `${reactRouterConfig.basename}${prerenderPath}/`.replace(
    /\/\/+/g,
    "/"
  );
  let request = new Request(`http://localhost${normalizedPath}`, requestInit);
  let response = await handler(request);
  let html = await response.text();
  validatePrerenderedResponse(response, html, "Prerender", normalizedPath);
  if (!reactRouterConfig.ssr) {
    validatePrerenderedHtml(html, "Prerender");
  }
  let outdir = path4.relative(process.cwd(), clientBuildDirectory);
  let outfile = path4.join(outdir, ...normalizedPath.split("/"), "index.html");
  await fse.ensureDir(path4.dirname(outfile));
  await fse.outputFile(outfile, html);
  viteConfig.logger.info(`Prerender: Generated ${import_picocolors3.default.bold(outfile)}`);
}
async function prerenderResourceRoute(handler, prerenderPath, clientBuildDirectory, reactRouterConfig, viteConfig, requestInit) {
  let normalizedPath = `${reactRouterConfig.basename}${prerenderPath}/`.replace(/\/\/+/g, "/").replace(/\/$/g, "");
  let request = new Request(`http://localhost${normalizedPath}`, requestInit);
  let response = await handler(request);
  let text = await response.text();
  validatePrerenderedResponse(response, text, "Prerender", normalizedPath);
  let outdir = path4.relative(process.cwd(), clientBuildDirectory);
  let outfile = path4.join(outdir, ...normalizedPath.split("/"));
  await fse.ensureDir(path4.dirname(outfile));
  await fse.outputFile(outfile, text);
  viteConfig.logger.info(`Prerender: Generated ${import_picocolors3.default.bold(outfile)}`);
}
async function prerenderManifest(build, clientBuildDirectory, reactRouterConfig, viteConfig) {
  let normalizedPath = `${reactRouterConfig.basename}/__manifest`.replace(
    /\/\/+/g,
    "/"
  );
  let outdir = path4.relative(process.cwd(), clientBuildDirectory);
  let outfile = path4.join(outdir, ...normalizedPath.split("/"));
  await fse.ensureDir(path4.dirname(outfile));
  let manifestData = JSON.stringify(build.assets.routes);
  await fse.outputFile(outfile, manifestData);
  viteConfig.logger.info(`Prerender: Generated ${import_picocolors3.default.bold(outfile)}`);
}
function validatePrerenderedResponse(response, html, prefix, path5) {
  if (response.status !== 200) {
    throw new Error(
      `${prefix}: Received a ${response.status} status code from \`entry.server.tsx\` while prerendering the \`${path5}\` path.
${html}`
    );
  }
}
function validatePrerenderedHtml(html, prefix) {
  if (!html.includes("window.__reactRouterContext =") || !html.includes("window.__reactRouterRouteModules =")) {
    throw new Error(
      `${prefix}: Did you forget to include <Scripts/> in your root route? Your pre-rendered HTML files cannot hydrate without \`<Scripts />\`.`
    );
  }
}
function groupRoutesByParentId2(manifest) {
  let routes = {};
  Object.values(manifest).forEach((route) => {
    if (route) {
      let parentId = route.parentId || "";
      if (!routes[parentId]) {
        routes[parentId] = [];
      }
      routes[parentId].push(route);
    }
  });
  return routes;
}
function createPrerenderRoutes(manifest, parentId = "", routesByParentId = groupRoutesByParentId2(manifest)) {
  return (routesByParentId[parentId] || []).map((route) => {
    let commonRoute = {
      // Always include root due to default boundaries
      hasErrorBoundary: route.id === "root" || route.module.ErrorBoundary != null,
      id: route.id,
      path: route.path,
      loader: route.module.loader ? () => null : void 0,
      action: void 0,
      handle: route.module.handle
    };
    return route.index ? {
      index: true,
      ...commonRoute
    } : {
      caseSensitive: route.caseSensitive,
      children: createPrerenderRoutes(manifest, route.id, routesByParentId),
      ...commonRoute
    };
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  reactRouter
});
