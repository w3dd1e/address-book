#!/usr/bin/env node
/**
 * @react-router/dev v7.0.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// invariant.ts
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    console.error(
      "The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose"
    );
    throw new Error(message);
  }
}
var init_invariant = __esm({
  "invariant.ts"() {
    "use strict";
  }
});

// vite/import-vite-esm-sync.ts
async function preloadViteEsm() {
  vite = await import("vite");
}
function importViteEsmSync() {
  invariant(vite, "importViteEsmSync() called before preloadViteEsm()");
  return vite;
}
var vite;
var init_import_vite_esm_sync = __esm({
  "vite/import-vite-esm-sync.ts"() {
    "use strict";
    init_invariant();
  }
});

// vite/vite-node.ts
async function createContext(viteConfig = {}) {
  await preloadViteEsm();
  const vite2 = importViteEsmSync();
  const devServer = await vite2.createServer(
    vite2.mergeConfig(
      {
        server: {
          preTransformRequests: false,
          hmr: false
        },
        optimizeDeps: {
          noDiscovery: true
        },
        configFile: false,
        envFile: false,
        plugins: []
      },
      viteConfig
    )
  );
  await devServer.pluginContainer.buildStart({});
  const server = new import_server.ViteNodeServer(devServer);
  (0, import_source_map.installSourcemapsSupport)({
    getSourceMap: (source) => server.getSourceMap(source)
  });
  const runner = new import_client.ViteNodeRunner({
    root: devServer.config.root,
    base: devServer.config.base,
    fetchModule(id2) {
      return server.fetchModule(id2);
    },
    resolveId(id2, importer) {
      return server.resolveId(id2, importer);
    }
  });
  return { devServer, server, runner };
}
var import_server, import_client, import_source_map;
var init_vite_node = __esm({
  "vite/vite-node.ts"() {
    "use strict";
    import_server = require("vite-node/server");
    import_client = require("vite-node/client");
    import_source_map = require("vite-node/source-map");
    init_import_vite_esm_sync();
  }
});

// config/routes.ts
function setAppDirectory(directory) {
  globalThis.__reactRouterAppDirectory = directory;
}
function validateRouteConfig({
  routeConfigFile,
  routeConfig
}) {
  if (!routeConfig) {
    return {
      valid: false,
      message: `Route config must be the default export in "${routeConfigFile}".`
    };
  }
  if (!Array.isArray(routeConfig)) {
    return {
      valid: false,
      message: `Route config in "${routeConfigFile}" must be an array.`
    };
  }
  let { issues } = v.safeParse(resolvedRouteConfigSchema, routeConfig);
  if (issues?.length) {
    let { root, nested } = v.flatten(issues);
    return {
      valid: false,
      message: [
        `Route config in "${routeConfigFile}" is invalid.`,
        root ? `${root}` : [],
        nested ? Object.entries(nested).map(
          ([path8, message]) => `Path: routes.${path8}
${message}`
        ) : []
      ].flat().join("\n\n")
    };
  }
  return { valid: true };
}
function configRoutesToRouteManifest(appDirectory, routes2, rootId = "root") {
  let routeManifest = {};
  function walk(route, parentId) {
    let id2 = route.id || createRouteId(route.file);
    let manifestItem = {
      id: id2,
      parentId,
      file: Path.isAbsolute(route.file) ? Path.relative(appDirectory, route.file) : route.file,
      path: route.path,
      index: route.index,
      caseSensitive: route.caseSensitive
    };
    if (routeManifest.hasOwnProperty(id2)) {
      throw new Error(
        `Unable to define routes with duplicate route id: "${id2}"`
      );
    }
    routeManifest[id2] = manifestItem;
    if (route.children) {
      for (let child of route.children) {
        walk(child, id2);
      }
    }
  }
  for (let route of routes2) {
    walk(route, rootId);
  }
  return routeManifest;
}
function createRouteId(file) {
  return Path.normalize(stripFileExtension(file));
}
function stripFileExtension(file) {
  return file.replace(/\.[a-z0-9]+$/i, "");
}
var Path, v, import_pick, routeConfigEntrySchema, resolvedRouteConfigSchema;
var init_routes = __esm({
  "config/routes.ts"() {
    "use strict";
    Path = __toESM(require("pathe"));
    v = __toESM(require("valibot"));
    import_pick = __toESM(require("lodash/pick"));
    init_invariant();
    routeConfigEntrySchema = v.pipe(
      v.custom((value) => {
        return !(typeof value === "object" && value !== null && "then" in value && "catch" in value);
      }, "Invalid type: Expected object but received a promise. Did you forget to await?"),
      v.object({
        id: v.optional(v.string()),
        path: v.optional(v.string()),
        index: v.optional(v.boolean()),
        caseSensitive: v.optional(v.boolean()),
        file: v.string(),
        children: v.optional(v.array(v.lazy(() => routeConfigEntrySchema)))
      })
    );
    resolvedRouteConfigSchema = v.array(routeConfigEntrySchema);
  }
});

// cli/detectPackageManager.ts
var init_detectPackageManager = __esm({
  "cli/detectPackageManager.ts"() {
    "use strict";
  }
});

// config/config.ts
function ok(value) {
  return { ok: true, value };
}
function err(error) {
  return { ok: false, error };
}
async function resolveConfig({
  root,
  viteNodeContext,
  reactRouterConfigFile
}) {
  let reactRouterUserConfig = {};
  if (reactRouterConfigFile) {
    try {
      if (!import_node_fs.default.existsSync(reactRouterConfigFile)) {
        return err(`${reactRouterConfigFile} no longer exists`);
      }
      let configModule = await viteNodeContext.runner.executeFile(
        reactRouterConfigFile
      );
      if (configModule.default === void 0) {
        return err(`${reactRouterConfigFile} must provide a default export`);
      }
      if (typeof configModule.default !== "object") {
        return err(`${reactRouterConfigFile} must export a config`);
      }
      reactRouterUserConfig = configModule.default;
    } catch (error) {
      return err(`Error loading ${reactRouterConfigFile}: ${error}`);
    }
  }
  reactRouterUserConfig = deepFreeze((0, import_cloneDeep.default)(reactRouterUserConfig));
  let presets = (await Promise.all(
    (reactRouterUserConfig.presets ?? []).map(async (preset) => {
      if (!preset.name) {
        throw new Error(
          "React Router presets must have a `name` property defined."
        );
      }
      if (!preset.reactRouterConfig) {
        return null;
      }
      let configPreset = (0, import_omit.default)(
        await preset.reactRouterConfig({ reactRouterUserConfig }),
        excludedConfigPresetKeys
      );
      return configPreset;
    })
  )).filter(function isNotNull(value) {
    return value !== null;
  });
  let defaults = {
    basename: "/",
    buildDirectory: "build",
    serverBuildFile: "index.js",
    serverModuleFormat: "esm",
    ssr: true
  };
  let {
    appDirectory: userAppDirectory,
    basename: basename2,
    buildDirectory: userBuildDirectory,
    buildEnd,
    prerender,
    serverBuildFile,
    serverBundles,
    serverModuleFormat,
    ssr
  } = {
    ...defaults,
    // Default values should be completely overridden by user/preset config, not merged
    ...mergeReactRouterConfig(...presets, reactRouterUserConfig)
  };
  if (!ssr && serverBundles) {
    serverBundles = void 0;
  }
  let isValidPrerenderConfig = prerender == null || typeof prerender === "boolean" || Array.isArray(prerender) || typeof prerender === "function";
  if (!isValidPrerenderConfig) {
    return err(
      "The `prerender` config must be a boolean, an array of string paths, or a function returning a boolean or array of string paths"
    );
  }
  let appDirectory = import_pathe.default.resolve(root, userAppDirectory || "app");
  let buildDirectory = import_pathe.default.resolve(root, userBuildDirectory);
  let rootRouteFile = findEntry(appDirectory, "root");
  if (!rootRouteFile) {
    let rootRouteDisplayPath = import_pathe.default.relative(
      root,
      import_pathe.default.join(appDirectory, "root.tsx")
    );
    return err(
      `Could not find a root route module in the app directory as "${rootRouteDisplayPath}"`
    );
  }
  let routes2 = {
    root: { path: "", id: "root", file: rootRouteFile }
  };
  let routeConfigFile = findEntry(appDirectory, "routes");
  try {
    if (!routeConfigFile) {
      let routeConfigDisplayPath = import_pathe.default.relative(
        root,
        import_pathe.default.join(appDirectory, "routes.ts")
      );
      return err(`Route config file not found at "${routeConfigDisplayPath}".`);
    }
    setAppDirectory(appDirectory);
    let routeConfigExport = (await viteNodeContext.runner.executeFile(
      import_pathe.default.join(appDirectory, routeConfigFile)
    )).default;
    let routeConfig = await routeConfigExport;
    let result = validateRouteConfig({
      routeConfigFile,
      routeConfig
    });
    if (!result.valid) {
      return err(result.message);
    }
    routes2 = {
      ...routes2,
      ...configRoutesToRouteManifest(appDirectory, routeConfig)
    };
  } catch (error) {
    return err(
      [
        import_picocolors.default.red(`Route config in "${routeConfigFile}" is invalid.`),
        "",
        error.loc?.file && error.loc?.column && error.frame ? [
          import_pathe.default.relative(appDirectory, error.loc.file) + ":" + error.loc.line + ":" + error.loc.column,
          error.frame.trim?.()
        ] : error.stack
      ].flat().join("\n")
    );
  }
  let future = {
    unstable_optimizeDeps: reactRouterUserConfig.future?.unstable_optimizeDeps ?? false
  };
  let reactRouterConfig = deepFreeze({
    appDirectory,
    basename: basename2,
    buildDirectory,
    buildEnd,
    future,
    prerender,
    routes: routes2,
    serverBuildFile,
    serverBundles,
    serverModuleFormat,
    ssr
  });
  for (let preset of reactRouterUserConfig.presets ?? []) {
    await preset.reactRouterConfigResolved?.({ reactRouterConfig });
  }
  return ok(reactRouterConfig);
}
async function createConfigLoader({
  rootDirectory: root,
  watch: watch2
}) {
  root = root ?? process.env.REACT_ROUTER_ROOT ?? process.cwd();
  let viteNodeContext = await createContext({
    root,
    mode: watch2 ? "development" : "production",
    server: !watch2 ? { watch: null } : {},
    ssr: {
      external: ssrExternals
    }
  });
  let reactRouterConfigFile = findEntry(root, "react-router.config", {
    absolute: true
  });
  let getConfig = () => resolveConfig({ root, viteNodeContext, reactRouterConfigFile });
  let appDirectory;
  let initialConfigResult = await getConfig();
  if (!initialConfigResult.ok) {
    throw new Error(initialConfigResult.error);
  }
  appDirectory = initialConfigResult.value.appDirectory;
  let lastConfig = initialConfigResult.value;
  let fsWatcher;
  let changeHandlers = [];
  return {
    getConfig,
    onChange: (handler) => {
      if (!watch2) {
        throw new Error(
          "onChange is not supported when watch mode is disabled"
        );
      }
      changeHandlers.push(handler);
      if (!fsWatcher) {
        fsWatcher = import_chokidar.default.watch(
          [
            ...reactRouterConfigFile ? [reactRouterConfigFile] : [],
            appDirectory
          ],
          { ignoreInitial: true }
        );
        fsWatcher.on("all", async (...args) => {
          let [event, rawFilepath] = args;
          let filepath = import_pathe.default.normalize(rawFilepath);
          let appFileAddedOrRemoved = appDirectory && (event === "add" || event === "unlink") && filepath.startsWith(import_pathe.default.normalize(appDirectory));
          let configCodeUpdated = Boolean(
            viteNodeContext.devServer?.moduleGraph.getModuleById(filepath)
          );
          if (configCodeUpdated || appFileAddedOrRemoved) {
            viteNodeContext.devServer?.moduleGraph.invalidateAll();
            viteNodeContext.runner?.moduleCache.clear();
          }
          if (appFileAddedOrRemoved || configCodeUpdated) {
            let result = await getConfig();
            let configChanged = result.ok && !(0, import_isEqual.default)(lastConfig, result.value);
            let routeConfigChanged = result.ok && !(0, import_isEqual.default)(lastConfig?.routes, result.value.routes);
            for (let handler2 of changeHandlers) {
              handler2({
                result,
                configCodeUpdated,
                configChanged,
                routeConfigChanged,
                path: filepath,
                event
              });
            }
            if (result.ok) {
              lastConfig = result.value;
            }
          }
        });
      }
      return () => {
        changeHandlers = changeHandlers.filter(
          (changeHandler) => changeHandler !== handler
        );
      };
    },
    close: async () => {
      changeHandlers = [];
      await viteNodeContext.devServer.close();
      await fsWatcher?.close();
    }
  };
}
function isInReactRouterMonorepo() {
  let serverRuntimePath = import_pathe.default.dirname(
    require.resolve("@react-router/node/package.json")
  );
  let serverRuntimeParentDir = import_pathe.default.basename(
    import_pathe.default.resolve(serverRuntimePath, "..")
  );
  return serverRuntimeParentDir === "packages";
}
function findEntry(dir, basename2, options) {
  for (let ext of entryExts) {
    let file = import_pathe.default.resolve(dir, basename2 + ext);
    if (import_node_fs.default.existsSync(file)) {
      return options?.absolute ?? false ? file : import_pathe.default.relative(dir, file);
    }
  }
  return void 0;
}
var import_node_fs, import_node_child_process, import_package_json, import_pathe, import_chokidar, import_picocolors, import_pick2, import_omit, import_cloneDeep, import_isEqual, excludedConfigPresetKeys, branchRouteProperties, configRouteToBranchRoute, mergeReactRouterConfig, deepFreeze, ssrExternals, entryExts;
var init_config = __esm({
  "config/config.ts"() {
    "use strict";
    import_node_fs = __toESM(require("fs"));
    import_node_child_process = require("child_process");
    import_package_json = __toESM(require("@npmcli/package-json"));
    init_vite_node();
    import_pathe = __toESM(require("pathe"));
    import_chokidar = __toESM(require("chokidar"));
    import_picocolors = __toESM(require("picocolors"));
    import_pick2 = __toESM(require("lodash/pick"));
    import_omit = __toESM(require("lodash/omit"));
    import_cloneDeep = __toESM(require("lodash/cloneDeep"));
    import_isEqual = __toESM(require("lodash/isEqual"));
    init_routes();
    init_detectPackageManager();
    excludedConfigPresetKeys = ["presets"];
    branchRouteProperties = [
      "id",
      "path",
      "file",
      "index"
    ];
    configRouteToBranchRoute = (configRoute) => (0, import_pick2.default)(configRoute, branchRouteProperties);
    mergeReactRouterConfig = (...configs) => {
      let reducer = (configA, configB) => {
        let mergeRequired = (key) => configA[key] !== void 0 && configB[key] !== void 0;
        return {
          ...configA,
          ...configB,
          ...mergeRequired("buildEnd") ? {
            buildEnd: async (...args) => {
              await Promise.all([
                configA.buildEnd?.(...args),
                configB.buildEnd?.(...args)
              ]);
            }
          } : {},
          ...mergeRequired("future") ? {
            future: {
              ...configA.future,
              ...configB.future
            }
          } : {},
          ...mergeRequired("presets") ? {
            presets: [...configA.presets ?? [], ...configB.presets ?? []]
          } : {}
        };
      };
      return configs.reduce(reducer, {});
    };
    deepFreeze = (o) => {
      Object.freeze(o);
      let oIsFunction = typeof o === "function";
      let hasOwnProp = Object.prototype.hasOwnProperty;
      Object.getOwnPropertyNames(o).forEach(function(prop) {
        if (hasOwnProp.call(o, prop) && (oIsFunction ? prop !== "caller" && prop !== "callee" && prop !== "arguments" : true) && o[prop] !== null && (typeof o[prop] === "object" || typeof o[prop] === "function") && !Object.isFrozen(o[prop])) {
          deepFreeze(o[prop]);
        }
      });
      return o;
    };
    ssrExternals = isInReactRouterMonorepo() ? [
      // This is only needed within this repo because these packages
      // are linked to a directory outside of node_modules so Vite
      // treats them as internal code by default.
      "react-router",
      "react-router-dom",
      "@react-router/architect",
      "@react-router/cloudflare",
      "@react-router/dev",
      "@react-router/express",
      "@react-router/node",
      "@react-router/serve"
    ] : void 0;
    entryExts = [".js", ".jsx", ".ts", ".tsx"];
  }
});

// typegen/paths.ts
function getTypesDir(ctx) {
  return Path2.join(ctx.rootDirectory, ".react-router/types");
}
function getTypesPath(ctx, route) {
  return Path2.join(
    getTypesDir(ctx),
    Path2.relative(ctx.rootDirectory, ctx.config.appDirectory),
    Path2.dirname(route.file),
    "+types/" + Pathe.filename(route.file) + ".ts"
  );
}
var Path2, Pathe;
var init_paths = __esm({
  "typegen/paths.ts"() {
    "use strict";
    Path2 = __toESM(require("pathe"));
    Pathe = __toESM(require("pathe/utils"));
  }
});

// typegen/generate.ts
function generate(ctx, route) {
  const lineage = getRouteLineage(ctx.config.routes, route);
  const urlpath = lineage.map((route2) => route2.path).join("/");
  const typesPath = getTypesPath(ctx, route);
  const parents = lineage.slice(0, -1);
  const parentTypeImports = parents.map((parent, i) => {
    const rel = Path3.relative(
      Path3.dirname(typesPath),
      getTypesPath(ctx, parent)
    );
    const indent = i === 0 ? "" : "  ".repeat(2);
    let source = noExtension(rel);
    if (!source.startsWith("../")) source = "./" + source;
    return `${indent}import type { Info as Parent${i} } from "${source}.js"`;
  }).join("\n");
  return import_dedent.default`
    // React Router generated types for route:
    // ${route.file}

    import type * as T from "react-router/route-module"

    ${parentTypeImports}

    type Module = typeof import("../${Pathe2.filename(route.file)}.js")

    export type Info = {
      parents: [${parents.map((_, i) => `Parent${i}`).join(", ")}],
      id: "${route.id}"
      file: "${route.file}"
      path: "${route.path}"
      params: {${formatParamProperties(
    urlpath
  )}} & { [key: string]: string | undefined }
      module: Module
      loaderData: T.CreateLoaderData<Module>
      actionData: T.CreateActionData<Module>
    }

    export namespace Route {
      export type LinkDescriptors = T.LinkDescriptors
      export type LinksFunction = () => LinkDescriptors

      export type MetaArgs = T.CreateMetaArgs<Info>
      export type MetaDescriptors = T.MetaDescriptors
      export type MetaFunction = (args: MetaArgs) => MetaDescriptors

      export type HeadersArgs = T.HeadersArgs
      export type HeadersFunction = (args: HeadersArgs) => Headers | HeadersInit

      export type LoaderArgs = T.CreateServerLoaderArgs<Info>
      export type ClientLoaderArgs = T.CreateClientLoaderArgs<Info>
      export type ActionArgs = T.CreateServerActionArgs<Info>
      export type ClientActionArgs = T.CreateClientActionArgs<Info>

      export type HydrateFallbackProps = T.CreateHydrateFallbackProps<Info>
      export type ComponentProps = T.CreateComponentProps<Info>
      export type ErrorBoundaryProps = T.CreateErrorBoundaryProps<Info>
    }
  `;
}
function getRouteLineage(routes2, route) {
  const result = [];
  while (route) {
    result.push(route);
    if (!route.parentId) break;
    route = routes2[route.parentId];
  }
  result.reverse();
  return result;
}
function formatParamProperties(urlpath) {
  const params = parseParams(urlpath);
  const properties = Object.entries(params).map(([name, values]) => {
    if (values.length === 1) {
      const isOptional = values[0];
      return isOptional ? `"${name}"?: string` : `"${name}": string`;
    }
    const items = values.map(
      (isOptional) => isOptional ? "string | undefined" : "string"
    );
    return `"${name}": [${items.join(", ")}]`;
  });
  return properties.join("; ");
}
function parseParams(urlpath) {
  const result = {};
  let segments = urlpath.split("/");
  segments.forEach((segment) => {
    const match = segment.match(/^:([\w-]+)(\?)?/);
    if (!match) return;
    const param = match[1];
    const isOptional = match[2] !== void 0;
    result[param] ??= [];
    result[param].push(isOptional);
    return;
  });
  const hasSplat = segments.at(-1) === "*";
  if (hasSplat) result["*"] = [false];
  return result;
}
var import_dedent, Path3, Pathe2, noExtension;
var init_generate = __esm({
  "typegen/generate.ts"() {
    "use strict";
    import_dedent = __toESM(require("dedent"));
    Path3 = __toESM(require("pathe"));
    Pathe2 = __toESM(require("pathe/utils"));
    init_paths();
    noExtension = (path8) => Path3.join(Path3.dirname(path8), Pathe2.filename(path8));
  }
});

// typegen/index.ts
async function run(rootDirectory) {
  const ctx = await createContext2({ rootDirectory, watch: false });
  await writeAll(ctx);
}
async function watch(rootDirectory, { logger } = {}) {
  const ctx = await createContext2({ rootDirectory, watch: true });
  await writeAll(ctx);
  logger?.info(import_picocolors2.default.green("generated types"), { timestamp: true, clear: true });
  ctx.configLoader.onChange(async ({ result, routeConfigChanged }) => {
    if (!result.ok) {
      logger?.error(import_picocolors2.default.red(result.error), { timestamp: true, clear: true });
      return;
    }
    ctx.config = result.value;
    if (routeConfigChanged) {
      await writeAll(ctx);
      logger?.info(import_picocolors2.default.green("regenerated types"), {
        timestamp: true,
        clear: true
      });
    }
  });
  return {
    close: async () => await ctx.configLoader.close()
  };
}
async function createContext2({
  rootDirectory,
  watch: watch2
}) {
  const configLoader = await createConfigLoader({ rootDirectory, watch: watch2 });
  const configResult = await configLoader.getConfig();
  if (!configResult.ok) {
    throw new Error(configResult.error);
  }
  const config = configResult.value;
  return {
    configLoader,
    rootDirectory,
    config
  };
}
async function writeAll(ctx) {
  const typegenDir = getTypesDir(ctx);
  import_node_fs2.default.rmSync(typegenDir, { recursive: true, force: true });
  Object.values(ctx.config.routes).forEach((route) => {
    const typesPath = getTypesPath(ctx, route);
    const content = generate(ctx, route);
    import_node_fs2.default.mkdirSync(Path4.dirname(typesPath), { recursive: true });
    import_node_fs2.default.writeFileSync(typesPath, content);
  });
}
var import_node_fs2, Path4, import_picocolors2;
var init_typegen = __esm({
  "typegen/index.ts"() {
    "use strict";
    import_node_fs2 = __toESM(require("fs"));
    Path4 = __toESM(require("pathe"));
    import_picocolors2 = __toESM(require("picocolors"));
    init_config();
    init_generate();
    init_paths();
  }
});

// vite/babel.ts
var import_parser, t, traverse, generate2;
var init_babel = __esm({
  "vite/babel.ts"() {
    "use strict";
    import_parser = require("@babel/parser");
    t = __toESM(require("@babel/types"));
    traverse = require("@babel/traverse").default;
    generate2 = require("@babel/generator").default;
  }
});

// vite/node-adapter.ts
var import_node_events, import_node_stream, import_set_cookie_parser, import_node;
var init_node_adapter = __esm({
  "vite/node-adapter.ts"() {
    "use strict";
    import_node_events = require("events");
    import_node_stream = require("stream");
    import_set_cookie_parser = require("set-cookie-parser");
    import_node = require("@react-router/node");
    init_invariant();
  }
});

// vite/resolve-file-url.ts
var path2;
var init_resolve_file_url = __esm({
  "vite/resolve-file-url.ts"() {
    "use strict";
    path2 = __toESM(require("path"));
    init_import_vite_esm_sync();
  }
});

// vite/styles.ts
var path3, import_react_router, cssFileRegExp, cssModulesRegExp;
var init_styles = __esm({
  "vite/styles.ts"() {
    "use strict";
    path3 = __toESM(require("path"));
    import_react_router = require("react-router");
    init_resolve_file_url();
    cssFileRegExp = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
    cssModulesRegExp = new RegExp(`\\.module${cssFileRegExp.source}`);
  }
});

// vite/vmod.ts
var id;
var init_vmod = __esm({
  "vite/vmod.ts"() {
    "use strict";
    id = (name) => `virtual:react-router/${name}`;
  }
});

// vite/combine-urls.ts
var init_combine_urls = __esm({
  "vite/combine-urls.ts"() {
    "use strict";
  }
});

// vite/remove-exports.ts
var import_babel_dead_code_elimination;
var init_remove_exports = __esm({
  "vite/remove-exports.ts"() {
    "use strict";
    import_babel_dead_code_elimination = require("babel-dead-code-elimination");
    init_babel();
  }
});

// vite/with-props.ts
var import_dedent2, vmodId;
var init_with_props = __esm({
  "vite/with-props.ts"() {
    "use strict";
    import_dedent2 = __toESM(require("dedent"));
    init_babel();
    init_vmod();
    vmodId = id("with-props");
  }
});

// vite/plugin.ts
async function resolveViteConfig({
  configFile,
  mode,
  root
}) {
  let vite2 = await import("vite");
  let viteConfig = await vite2.resolveConfig(
    { mode, configFile, root },
    "build",
    // command
    "production",
    // default mode
    "production"
    // default NODE_ENV
  );
  if (typeof viteConfig.build.manifest === "string") {
    throw new Error("Custom Vite manifest paths are not supported");
  }
  return viteConfig;
}
async function extractPluginContext(viteConfig) {
  return viteConfig["__reactRouterPluginContext"];
}
async function loadPluginContext({
  configFile,
  root
}) {
  if (!root) {
    root = process.env.REACT_ROUTER_ROOT || process.cwd();
  }
  configFile = configFile ?? findConfig(root, "vite.config", [
    ".ts",
    ".cts",
    ".mts",
    ".js",
    ".cjs",
    ".mjs"
  ]);
  if (!configFile) {
    console.error(import_picocolors3.default.red("Vite config file not found"));
    process.exit(1);
  }
  let viteConfig = await resolveViteConfig({ configFile, root });
  let ctx = await extractPluginContext(viteConfig);
  if (!ctx) {
    console.error(
      import_picocolors3.default.red("React Router Vite plugin not found in Vite config")
    );
    process.exit(1);
  }
  return ctx;
}
function findConfig(dir, basename2, extensions) {
  for (let ext of extensions) {
    let name = basename2 + ext;
    let file = path4.join(dir, name);
    if (fse.existsSync(file)) return file;
  }
  return void 0;
}
var import_node_crypto, path4, url, fse, babel, import_react_router2, import_es_module_lexer, import_jsesc, import_picocolors3, serverBuildId, serverManifestId, browserManifestId, hmrRuntimeId, injectHmrRuntimeId, getServerBuildDirectory, defaultEntriesDir, defaultEntries, REACT_REFRESH_HEADER, REACT_REFRESH_FOOTER;
var init_plugin = __esm({
  "vite/plugin.ts"() {
    "use strict";
    import_node_crypto = require("crypto");
    path4 = __toESM(require("path"));
    url = __toESM(require("url"));
    fse = __toESM(require("fs-extra"));
    babel = __toESM(require("@babel/core"));
    import_react_router2 = require("react-router");
    import_es_module_lexer = require("es-module-lexer");
    import_jsesc = __toESM(require("jsesc"));
    import_picocolors3 = __toESM(require("picocolors"));
    init_typegen();
    init_invariant();
    init_babel();
    init_node_adapter();
    init_styles();
    init_vmod();
    init_resolve_file_url();
    init_combine_urls();
    init_remove_exports();
    init_import_vite_esm_sync();
    init_config();
    init_with_props();
    serverBuildId = id("server-build");
    serverManifestId = id("server-manifest");
    browserManifestId = id("browser-manifest");
    hmrRuntimeId = id("hmr-runtime");
    injectHmrRuntimeId = id("inject-hmr-runtime");
    getServerBuildDirectory = (ctx) => path4.join(
      ctx.reactRouterConfig.buildDirectory,
      "server",
      ...ctx.serverBundleBuildConfig ? [ctx.serverBundleBuildConfig.serverBundleId] : []
    );
    defaultEntriesDir = path4.resolve(
      path4.dirname(require.resolve("@react-router/dev/package.json")),
      "dist",
      "config",
      "defaults"
    );
    defaultEntries = fse.readdirSync(defaultEntriesDir).map((filename3) => path4.join(defaultEntriesDir, filename3));
    invariant(defaultEntries.length > 0, "No default entries found");
    REACT_REFRESH_HEADER = `
import RefreshRuntime from "${hmrRuntimeId}";

const inWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
let prevRefreshReg;
let prevRefreshSig;

if (import.meta.hot && !inWebWorker) {
  if (!window.__vite_plugin_react_preamble_installed__) {
    throw new Error(
      "React Router Vite plugin can't detect preamble. Something is wrong."
    );
  }

  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id) => {
    RefreshRuntime.register(type, __SOURCE__ + " " + id)
  };
  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;
}`.trim();
    REACT_REFRESH_FOOTER = `
if (import.meta.hot && !inWebWorker) {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {
    RefreshRuntime.registerExportsForReactRefresh(__SOURCE__, currentExports);
    import.meta.hot.accept((nextExports) => {
      if (!nextExports) return;
      __ROUTE_ID__ && window.__reactRouterRouteModuleUpdates.set(__ROUTE_ID__, nextExports);
      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(currentExports, nextExports, __ACCEPT_EXPORTS__);
      if (invalidateMessage) import.meta.hot.invalidate(invalidateMessage);
    });
  });
}`.trim();
  }
});

// vite/profiler.ts
var import_node_fs3, import_node_path, import_picocolors4, getSession, start, profileCount, stop;
var init_profiler = __esm({
  "vite/profiler.ts"() {
    "use strict";
    import_node_fs3 = __toESM(require("fs"));
    import_node_path = __toESM(require("path"));
    import_picocolors4 = __toESM(require("picocolors"));
    getSession = () => global.__reactRouter_profile_session;
    start = async (callback) => {
      let inspector = await import("inspector").then((r) => r.default);
      let session = global.__reactRouter_profile_session = new inspector.Session();
      session.connect();
      session.post("Profiler.enable", () => {
        session.post("Profiler.start", callback);
      });
    };
    profileCount = 0;
    stop = (log) => {
      let session = getSession();
      if (!session) return;
      return new Promise((res, rej) => {
        session.post("Profiler.stop", (err2, { profile }) => {
          if (err2) return rej(err2);
          let outPath = import_node_path.default.resolve(`./react-router-${profileCount++}.cpuprofile`);
          import_node_fs3.default.writeFileSync(outPath, JSON.stringify(profile));
          log(
            import_picocolors4.default.yellow(
              `CPU profile written to ${import_picocolors4.default.white(import_picocolors4.default.dim(outPath))}`
            )
          );
          global.__reactRouter_profile_session = void 0;
          res();
        });
      });
    };
  }
});

// vite/build.ts
var build_exports = {};
__export(build_exports, {
  build: () => build
});
function getAddressableRoutes(routes2) {
  let nonAddressableIds = /* @__PURE__ */ new Set();
  for (let id2 in routes2) {
    let route = routes2[id2];
    if (route.index) {
      invariant(
        route.parentId,
        `Expected index route "${route.id}" to have "parentId" set`
      );
      nonAddressableIds.add(route.parentId);
    }
    if (typeof route.path !== "string" && !route.index) {
      nonAddressableIds.add(id2);
    }
  }
  return Object.values(routes2).filter(
    (route) => !nonAddressableIds.has(route.id)
  );
}
function getRouteBranch(routes2, routeId) {
  let branch = [];
  let currentRouteId = routeId;
  while (currentRouteId) {
    let route = routes2[currentRouteId];
    invariant(route, `Missing route for ${currentRouteId}`);
    branch.push(route);
    currentRouteId = route.parentId;
  }
  return branch.reverse();
}
async function getServerBuilds(ctx) {
  let { rootDirectory } = ctx;
  const { routes: routes2, serverBuildFile, serverBundles, appDirectory } = ctx.reactRouterConfig;
  let serverBuildDirectory = getServerBuildDirectory(ctx);
  if (!serverBundles) {
    return {
      serverBuilds: [{ ssr: true }],
      buildManifest: { routes: routes2 }
    };
  }
  let { normalizePath } = await import("vite");
  let resolvedAppDirectory = import_node_path2.default.resolve(rootDirectory, appDirectory);
  let rootRelativeRoutes = Object.fromEntries(
    Object.entries(routes2).map(([id2, route]) => {
      let filePath = import_node_path2.default.join(resolvedAppDirectory, route.file);
      let rootRelativeFilePath = normalizePath(
        import_node_path2.default.relative(rootDirectory, filePath)
      );
      return [id2, { ...route, file: rootRelativeFilePath }];
    })
  );
  let buildManifest = {
    serverBundles: {},
    routeIdToServerBundleId: {},
    routes: rootRelativeRoutes
  };
  let serverBundleBuildConfigById = /* @__PURE__ */ new Map();
  await Promise.all(
    getAddressableRoutes(routes2).map(async (route) => {
      let branch = getRouteBranch(routes2, route.id);
      let serverBundleId = await serverBundles({
        branch: branch.map(
          (route2) => configRouteToBranchRoute({
            ...route2,
            // Ensure absolute paths are passed to the serverBundles function
            file: import_node_path2.default.join(resolvedAppDirectory, route2.file)
          })
        )
      });
      if (typeof serverBundleId !== "string") {
        throw new Error(`The "serverBundles" function must return a string`);
      }
      if (!/^[a-zA-Z0-9-_]+$/.test(serverBundleId)) {
        throw new Error(
          `The "serverBundles" function must only return strings containing alphanumeric characters, hyphens and underscores.`
        );
      }
      buildManifest.routeIdToServerBundleId[route.id] = serverBundleId;
      let relativeServerBundleDirectory = import_node_path2.default.relative(
        rootDirectory,
        import_node_path2.default.join(serverBuildDirectory, serverBundleId)
      );
      let serverBuildConfig = serverBundleBuildConfigById.get(serverBundleId);
      if (!serverBuildConfig) {
        buildManifest.serverBundles[serverBundleId] = {
          id: serverBundleId,
          file: normalizePath(
            import_node_path2.default.join(relativeServerBundleDirectory, serverBuildFile)
          )
        };
        serverBuildConfig = {
          routes: {},
          serverBundleId
        };
        serverBundleBuildConfigById.set(serverBundleId, serverBuildConfig);
      }
      for (let route2 of branch) {
        serverBuildConfig.routes[route2.id] = route2;
      }
    })
  );
  let serverBuilds = Array.from(serverBundleBuildConfigById.values()).map(
    (serverBundleBuildConfig) => {
      let serverBuild = {
        ssr: true,
        serverBundleBuildConfig
      };
      return serverBuild;
    }
  );
  return {
    serverBuilds,
    buildManifest
  };
}
async function cleanBuildDirectory(viteConfig, ctx) {
  let buildDirectory = ctx.reactRouterConfig.buildDirectory;
  let isWithinRoot = () => {
    let relativePath = import_node_path2.default.relative(ctx.rootDirectory, buildDirectory);
    return !relativePath.startsWith("..") && !import_node_path2.default.isAbsolute(relativePath);
  };
  if (viteConfig.build.emptyOutDir ?? isWithinRoot()) {
    await import_fs_extra.default.remove(buildDirectory);
  }
}
function getViteManifestPaths(ctx, serverBuilds) {
  let buildRelative = (pathname) => import_node_path2.default.resolve(ctx.reactRouterConfig.buildDirectory, pathname);
  let viteManifestPaths = [
    "client/.vite/manifest.json",
    ...serverBuilds.map(({ serverBundleBuildConfig }) => {
      let serverBundleId = serverBundleBuildConfig?.serverBundleId;
      let serverBundlePath = serverBundleId ? serverBundleId + "/" : "";
      return `server/${serverBundlePath}.vite/manifest.json`;
    })
  ].map((srcPath) => buildRelative(srcPath));
  return viteManifestPaths;
}
async function build(root, {
  assetsInlineLimit,
  clearScreen,
  config: configFile,
  emptyOutDir,
  force,
  logLevel,
  minify,
  mode,
  sourcemapClient,
  sourcemapServer
}) {
  await preloadViteEsm();
  let viteConfig = await resolveViteConfig({ configFile, mode, root });
  const ctx = await extractPluginContext(viteConfig);
  if (!ctx) {
    console.error(
      import_picocolors5.default.red("React Router Vite plugin not found in Vite config")
    );
    process.exit(1);
  }
  let { reactRouterConfig } = ctx;
  let vite2 = await import("vite");
  async function viteBuild({
    ssr,
    serverBundleBuildConfig
  }) {
    await vite2.build({
      root,
      mode,
      configFile,
      build: {
        assetsInlineLimit,
        emptyOutDir,
        minify,
        ssr,
        sourcemap: ssr ? sourcemapServer : sourcemapClient
      },
      optimizeDeps: { force },
      clearScreen,
      logLevel,
      ...serverBundleBuildConfig ? { __reactRouterServerBundleBuildConfig: serverBundleBuildConfig } : {}
    });
  }
  await cleanBuildDirectory(viteConfig, ctx);
  await viteBuild({ ssr: false });
  let { serverBuilds, buildManifest } = await getServerBuilds(ctx);
  await Promise.all(serverBuilds.map(viteBuild));
  let viteManifestPaths = getViteManifestPaths(ctx, serverBuilds);
  await Promise.all(
    viteManifestPaths.map(async (viteManifestPath) => {
      let manifestExists = await import_fs_extra.default.pathExists(viteManifestPath);
      if (!manifestExists) return;
      if (!ctx.viteManifestEnabled) {
        await import_fs_extra.default.remove(viteManifestPath);
      }
      let viteDir = import_node_path2.default.dirname(viteManifestPath);
      let viteDirFiles = await import_fs_extra.default.readdir(viteDir);
      if (viteDirFiles.length === 0) {
        await import_fs_extra.default.remove(viteDir);
      }
    })
  );
  await reactRouterConfig.buildEnd?.({
    buildManifest,
    reactRouterConfig,
    viteConfig
  });
}
var import_node_path2, import_fs_extra, import_picocolors5;
var init_build = __esm({
  "vite/build.ts"() {
    "use strict";
    import_node_path2 = __toESM(require("path"));
    import_fs_extra = __toESM(require("fs-extra"));
    import_picocolors5 = __toESM(require("picocolors"));
    init_plugin();
    init_config();
    init_invariant();
    init_import_vite_esm_sync();
  }
});

// vite/dev.ts
var dev_exports = {};
__export(dev_exports, {
  dev: () => dev
});
async function dev(root, {
  clearScreen,
  config: configFile,
  cors,
  force,
  host,
  logLevel,
  mode,
  open,
  port,
  strictPort
}) {
  await preloadViteEsm();
  let vite2 = await import("vite");
  let server = await vite2.createServer({
    root,
    mode,
    configFile,
    server: { open, cors, host, port, strictPort },
    optimizeDeps: { force },
    clearScreen,
    logLevel
  });
  if (!server.config.plugins.find((plugin2) => plugin2.name === "react-router")) {
    console.error(
      import_picocolors6.default.red("React Router Vite plugin not found in Vite config")
    );
    process.exit(1);
  }
  await server.listen();
  server.printUrls();
  let customShortcuts = [
    {
      key: "p",
      description: "start/stop the profiler",
      async action(server2) {
        if (getSession()) {
          await stop(server2.config.logger.info);
        } else {
          await start(() => {
            server2.config.logger.info("Profiler started");
          });
        }
      }
    }
  ];
  server.bindCLIShortcuts({ print: true, customShortcuts });
}
var import_picocolors6;
var init_dev = __esm({
  "vite/dev.ts"() {
    "use strict";
    import_picocolors6 = __toESM(require("picocolors"));
    init_import_vite_esm_sync();
    init_profiler();
  }
});

// cli/run.ts
var import_arg = __toESM(require("arg"));
var import_semver = __toESM(require("semver"));
var import_picocolors8 = __toESM(require("picocolors"));

// cli/commands.ts
var path7 = __toESM(require("path"));
var import_fs_extra2 = __toESM(require("fs-extra"));
var import_package_json2 = __toESM(require("@npmcli/package-json"));
var import_exit_hook = __toESM(require("exit-hook"));
var import_picocolors7 = __toESM(require("picocolors"));

// config/format.ts
function formatRoutes(routeManifest, format) {
  switch (format) {
    case "json":
      return formatRoutesAsJson(routeManifest);
    case "jsx":
      return formatRoutesAsJsx(routeManifest);
  }
}
function formatRoutesAsJson(routeManifest) {
  function handleRoutesRecursive(parentId) {
    let routes2 = Object.values(routeManifest).filter(
      (route) => route.parentId === parentId
    );
    let children = [];
    for (let route of routes2) {
      children.push({
        id: route.id,
        index: route.index,
        path: route.path,
        caseSensitive: route.caseSensitive,
        file: route.file,
        children: handleRoutesRecursive(route.id)
      });
    }
    if (children.length > 0) {
      return children;
    }
    return void 0;
  }
  return JSON.stringify(handleRoutesRecursive() || null, null, 2);
}
function formatRoutesAsJsx(routeManifest) {
  let output = "<Routes>";
  function handleRoutesRecursive(parentId, level = 1) {
    let routes2 = Object.values(routeManifest).filter(
      (route) => route.parentId === parentId
    );
    let indent = Array(level * 2).fill(" ").join("");
    for (let route of routes2) {
      output += "\n" + indent;
      output += `<Route${route.path ? ` path=${JSON.stringify(route.path)}` : ""}${route.index ? " index" : ""}${route.file ? ` file=${JSON.stringify(route.file)}` : ""}>`;
      if (handleRoutesRecursive(route.id, level + 1)) {
        output += "\n" + indent;
        output += "</Route>";
      } else {
        output = output.slice(0, -1) + " />";
      }
    }
    return routes2.length > 0;
  }
  handleRoutesRecursive();
  output += "\n</Routes>";
  return output;
}

// cli/commands.ts
init_plugin();

// cli/useJavascript.ts
var babel2 = __toESM(require("@babel/core"));
var import_plugin_syntax_jsx = __toESM(require("@babel/plugin-syntax-jsx"));
var import_preset_typescript = __toESM(require("@babel/preset-typescript"));
var import_prettier = __toESM(require("prettier"));
function transpile(tsx, options = {}) {
  let mjs = babel2.transformSync(tsx, {
    compact: false,
    cwd: options.cwd,
    filename: options.filename,
    plugins: [import_plugin_syntax_jsx.default],
    presets: [[import_preset_typescript.default, { jsx: "preserve" }]],
    retainLines: true
  });
  if (!mjs || !mjs.code) throw new Error("Could not parse TypeScript");
  return import_prettier.default.format(mjs.code, { parser: "babel" });
}

// cli/commands.ts
init_profiler();
init_typegen();
init_import_vite_esm_sync();
async function routes(reactRouterRoot, flags = {}) {
  let ctx = await loadPluginContext({
    root: reactRouterRoot,
    configFile: flags.config
  });
  if (!ctx) {
    console.error(
      import_picocolors7.default.red("React Router Vite plugin not found in Vite config")
    );
    process.exit(1);
  }
  let format = flags.json ? "json" : "jsx";
  console.log(formatRoutes(ctx.reactRouterConfig.routes, format));
}
async function build2(root, options = {}) {
  if (!root) {
    root = process.env.REACT_ROUTER_ROOT || process.cwd();
  }
  let { build: build3 } = await Promise.resolve().then(() => (init_build(), build_exports));
  if (options.profile) {
    await start();
  }
  try {
    await build3(root, options);
  } finally {
    await stop(console.info);
  }
}
async function dev2(root, options = {}) {
  let { dev: dev3 } = await Promise.resolve().then(() => (init_dev(), dev_exports));
  if (options.profile) {
    await start();
  }
  (0, import_exit_hook.default)(() => stop(console.info));
  await dev3(root, options);
  await new Promise(() => {
  });
}
var clientEntries = ["entry.client.tsx", "entry.client.js", "entry.client.jsx"];
var serverEntries = ["entry.server.tsx", "entry.server.js", "entry.server.jsx"];
var entries = ["entry.client", "entry.server"];
var conjunctionListFormat = new Intl.ListFormat("en", {
  style: "long",
  type: "conjunction"
});
async function generateEntry(entry, reactRouterRoot, flags = {}) {
  let ctx = await loadPluginContext({
    root: reactRouterRoot,
    configFile: flags.config
  });
  let rootDirectory = ctx.rootDirectory;
  let appDirectory = ctx.reactRouterConfig.appDirectory;
  if (!entry) {
    await generateEntry("entry.client", reactRouterRoot, flags);
    await generateEntry("entry.server", reactRouterRoot, flags);
    return;
  }
  if (!entries.includes(entry)) {
    let entriesArray = Array.from(entries);
    let list = conjunctionListFormat.format(entriesArray);
    console.error(
      import_picocolors7.default.red(`Invalid entry file. Valid entry files are ${list}`)
    );
    return;
  }
  let pkgJson = await import_package_json2.default.load(rootDirectory);
  let deps = pkgJson.content.dependencies ?? {};
  if (!deps["@react-router/node"]) {
    console.error(import_picocolors7.default.red(`No default server entry detected.`));
    return;
  }
  let defaultsDirectory = path7.resolve(
    path7.dirname(require.resolve("@react-router/dev/package.json")),
    "dist",
    "config",
    "defaults"
  );
  let defaultEntryClient = path7.resolve(defaultsDirectory, "entry.client.tsx");
  let defaultEntryServer = path7.resolve(
    defaultsDirectory,
    `entry.server.node.tsx`
  );
  let isServerEntry = entry === "entry.server";
  let contents = isServerEntry ? await createServerEntry(rootDirectory, appDirectory, defaultEntryServer) : await createClientEntry(rootDirectory, appDirectory, defaultEntryClient);
  let useTypeScript = flags.typescript ?? true;
  let outputExtension = useTypeScript ? "tsx" : "jsx";
  let outputEntry = `${entry}.${outputExtension}`;
  let outputFile2 = path7.resolve(appDirectory, outputEntry);
  if (!useTypeScript) {
    let javascript = transpile(contents, {
      cwd: rootDirectory,
      filename: isServerEntry ? defaultEntryServer : defaultEntryClient
    });
    await import_fs_extra2.default.writeFile(outputFile2, javascript, "utf-8");
  } else {
    await import_fs_extra2.default.writeFile(outputFile2, contents, "utf-8");
  }
  console.log(
    import_picocolors7.default.blue(
      `Entry file ${entry} created at ${path7.relative(
        rootDirectory,
        outputFile2
      )}.`
    )
  );
}
async function checkForEntry(rootDirectory, appDirectory, entries2) {
  for (let entry of entries2) {
    let entryPath = path7.resolve(appDirectory, entry);
    let exists = await import_fs_extra2.default.pathExists(entryPath);
    if (exists) {
      let relative8 = path7.relative(rootDirectory, entryPath);
      console.error(import_picocolors7.default.red(`Entry file ${relative8} already exists.`));
      return process.exit(1);
    }
  }
}
async function createServerEntry(rootDirectory, appDirectory, inputFile) {
  await checkForEntry(rootDirectory, appDirectory, serverEntries);
  let contents = await import_fs_extra2.default.readFile(inputFile, "utf-8");
  return contents;
}
async function createClientEntry(rootDirectory, appDirectory, inputFile) {
  await checkForEntry(rootDirectory, appDirectory, clientEntries);
  let contents = await import_fs_extra2.default.readFile(inputFile, "utf-8");
  return contents;
}
async function typegen(root, flags) {
  root ??= process.cwd();
  if (flags.watch) {
    await preloadViteEsm();
    const vite2 = importViteEsmSync();
    const logger = vite2.createLogger("info", { prefix: "[react-router]" });
    await watch(root, { logger });
    await new Promise(() => {
    });
    return;
  }
  await run(root);
}

// cli/run.ts
var helpText = `
${import_picocolors8.default.blueBright("react-router")}

  ${import_picocolors8.default.underline("Usage")}:
    $ react-router build [${import_picocolors8.default.yellowBright("projectDir")}]
    $ react-router dev [${import_picocolors8.default.yellowBright("projectDir")}]
    $ react-router routes [${import_picocolors8.default.yellowBright("projectDir")}]

  ${import_picocolors8.default.underline("Options")}:
    --help, -h          Print this help message and exit
    --version, -v       Print the CLI version and exit
    --no-color          Disable ANSI colors in console output
  \`build\` Options:
    --assetsInlineLimit Static asset base64 inline threshold in bytes (default: 4096) (number)
    --clearScreen       Allow/disable clear screen when logging (boolean)
    --config, -c        Use specified config file (string)
    --emptyOutDir       Force empty outDir when it's outside of root (boolean)
    --logLevel, -l      Info | warn | error | silent (string)
    --minify            Enable/disable minification, or specify minifier to use (default: "esbuild") (boolean | "terser" | "esbuild")
    --mode, -m          Set env mode (string)
    --profile           Start built-in Node.js inspector
    --sourcemapClient   Output source maps for client build (default: false) (boolean | "inline" | "hidden")
    --sourcemapServer   Output source maps for server build (default: false) (boolean | "inline" | "hidden")
  \`dev\` Options:
    --clearScreen       Allow/disable clear screen when logging (boolean)
    --config, -c        Use specified config file (string)
    --cors              Enable CORS (boolean)
    --force             Force the optimizer to ignore the cache and re-bundle (boolean)
    --host              Specify hostname (string)
    --logLevel, -l      Info | warn | error | silent (string)
    --mode, -m          Set env mode (string)
    --open              Open browser on startup (boolean | string)
    --port              Specify port (number)
    --profile           Start built-in Node.js inspector
    --strictPort        Exit if specified port is already in use (boolean)
  \`routes\` Options:
    --config, -c        Use specified Vite config file (string)
    --json              Print the routes as JSON
  \`reveal\` Options:
    --config, -c        Use specified Vite config file (string)
    --no-typescript     Generate plain JavaScript files
  \`typegen\` Options:
    --watch             Automatically regenerate types whenever route config (\`routes.ts\`) or route modules change

  ${import_picocolors8.default.underline("Build your project")}:

    $ react-router build

  ${import_picocolors8.default.underline("Run your project locally in development")}:

    $ react-router dev

  ${import_picocolors8.default.underline("Show all routes in your app")}:

    $ react-router routes
    $ react-router routes my-app
    $ react-router routes --json
    $ react-router routes --config vite.react-router.config.ts

  ${import_picocolors8.default.underline("Reveal the used entry point")}:

    $ react-router reveal entry.client
    $ react-router reveal entry.server
    $ react-router reveal entry.client --no-typescript
    $ react-router reveal entry.server --no-typescript
    $ react-router reveal entry.server --config vite.react-router.config.ts

  ${import_picocolors8.default.underline("Generate types for route modules")}:

   $ react-router typegen
   $ react-router typegen --watch
`;
async function run2(argv = process.argv.slice(2)) {
  let versions = process.versions;
  let MINIMUM_NODE_VERSION = 20;
  if (versions && versions.node && import_semver.default.major(versions.node) < MINIMUM_NODE_VERSION) {
    console.warn(
      `\uFE0F\u26A0\uFE0F Oops, Node v${versions.node} detected. react-router requires a Node version greater than ${MINIMUM_NODE_VERSION}.`
    );
  }
  let isBooleanFlag = (arg2) => {
    let index = argv.indexOf(arg2);
    let nextArg = argv[index + 1];
    return !nextArg || nextArg.startsWith("-");
  };
  let args = (0, import_arg.default)(
    {
      "--force": Boolean,
      "--help": Boolean,
      "-h": "--help",
      "--json": Boolean,
      "--token": String,
      "--typescript": Boolean,
      "--no-typescript": Boolean,
      "--version": Boolean,
      "-v": "--version",
      "--port": Number,
      "-p": "--port",
      "--config": String,
      "-c": "--config",
      "--assetsInlineLimit": Number,
      "--clearScreen": Boolean,
      "--cors": Boolean,
      "--emptyOutDir": Boolean,
      "--host": isBooleanFlag("--host") ? Boolean : String,
      "--logLevel": String,
      "-l": "--logLevel",
      "--minify": String,
      "--mode": String,
      "-m": "--mode",
      "--open": isBooleanFlag("--open") ? Boolean : String,
      "--strictPort": Boolean,
      "--profile": Boolean,
      "--sourcemapClient": isBooleanFlag("--sourcemapClient") ? Boolean : String,
      "--sourcemapServer": isBooleanFlag("--sourcemapServer") ? Boolean : String,
      "--watch": Boolean
    },
    {
      argv
    }
  );
  let input = args._;
  let flags = Object.entries(args).reduce((acc, [key, value]) => {
    key = key.replace(/^--/, "");
    acc[key] = value;
    return acc;
  }, {});
  if (flags.help) {
    console.log(helpText);
    return;
  }
  if (flags.version) {
    let version = require("../package.json").version;
    console.log(version);
    return;
  }
  flags.interactive = flags.interactive ?? require.main === module;
  if (args["--no-typescript"]) {
    flags.typescript = false;
  }
  let command = input[0];
  switch (command) {
    case "routes":
      await routes(input[1], flags);
      break;
    case "build":
      await build2(input[1], flags);
      break;
    case "reveal": {
      await generateEntry(input[1], input[2], flags);
      break;
    }
    case "dev":
      await dev2(input[1], flags);
      break;
    case "typegen":
      await typegen(input[1], flags);
      break;
    default:
      await dev2(input[0], flags);
  }
}

// cli/index.ts
run2().then(
  () => {
    process.exit(0);
  },
  (error) => {
    if (error) console.error(error);
    process.exit(1);
  }
);
